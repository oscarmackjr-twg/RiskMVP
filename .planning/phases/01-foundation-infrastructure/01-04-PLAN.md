---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - terraform/main.tf
  - terraform/variables.tf
  - terraform/outputs.tf
  - terraform/vpc.tf
  - terraform/rds.tf
  - terraform/ecs.tf
  - terraform/ecr.tf
  - terraform/.gitignore
  - terraform/README.md
autonomous: true

must_haves:
  truths:
    - "terraform apply creates complete AWS infrastructure"
    - "VPC with public/private subnets and NAT gateway exists"
    - "Aurora PostgreSQL cluster accessible from ECS tasks"
    - "ECS Fargate cluster runs all 4 services + worker"
    - "ALB routes requests to services via path-based routing"
    - "ECR repositories exist for all 4 service images"
  artifacts:
    - path: "terraform/main.tf"
      provides: "Root Terraform configuration with providers"
      min_lines: 20
      contains: "terraform {"
    - path: "terraform/vpc.tf"
      provides: "VPC with subnets, NAT, IGW"
      min_lines: 30
      contains: "resource \"aws_vpc\""
    - path: "terraform/rds.tf"
      provides: "Aurora PostgreSQL cluster with RDS Proxy"
      min_lines: 40
      contains: "resource \"aws_rds_cluster\""
    - path: "terraform/ecs.tf"
      provides: "ECS Fargate cluster, task definitions, and ALB with path routing"
      min_lines: 50
      contains: "resource \"aws_ecs_cluster\""
    - path: "terraform/ecr.tf"
      provides: "ECR repositories for all images"
      min_lines: 20
      contains: "resource \"aws_ecr_repository\""
  key_links:
    - from: "terraform/ecs.tf"
      to: "terraform/vpc.tf"
      via: "subnet and security group references"
      pattern: "subnet_ids.*aws_subnet"
    - from: "terraform/rds.tf"
      to: "terraform/vpc.tf"
      via: "subnet group and security group"
      pattern: "db_subnet_group_name"
    - from: "terraform/ecs.tf (ALB listener rules)"
      to: "terraform/ecs.tf (target groups)"
      via: "path-based routing to service target groups"
      pattern: "path_pattern.*forward"
---

<objective>
Provision complete AWS infrastructure with Terraform for production deployment.

Purpose: Completes PLAT-04 (Terraform AWS infrastructure). Establishes VPC, ECS Fargate, Aurora PostgreSQL, ALB with path-based routing, and ECR. Research confirms Terraform is industry standard in finance for declarative IaC.

Output: terraform apply deploys full AWS stack. Developers can destroy/recreate infrastructure in <5 minutes.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# Codebase context
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md

# Docker context (from 01-03)
# Docker images are now built and ready for ECR push
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Terraform VPC and networking infrastructure</name>
  <files>
terraform/main.tf
terraform/variables.tf
terraform/outputs.tf
terraform/vpc.tf
terraform/.gitignore
  </files>
  <action>
Create Terraform configuration for AWS VPC with public/private subnets.

**main.tf:**
```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}
```

**variables.tf:**
Define variables:
- aws_region (default: "us-east-1")
- environment (default: "dev")
- project_name (default: "iprs")
- vpc_cidr (default: "10.0.0.0/16")
- availability_zones (default: ["us-east-1a", "us-east-1b"])
- db_master_password (sensitive)

**vpc.tf:**
Create:
- VPC with DNS enabled
- 2 public subnets (for NAT and load balancer)
- 2 private subnets (for ECS tasks and RDS)
- Internet Gateway
- NAT Gateway (1 for cost optimization in dev)
- Route tables for public and private subnets
- Security groups for ECS tasks, RDS, and ALB

Research confirms:
- Multi-AZ deployment for high availability
- Private subnets for compute and data layers
- NAT gateway for outbound internet from private subnets

**outputs.tf:**
Output VPC ID, subnet IDs, security group IDs (needed for ECS and RDS modules).

**.gitignore:**
Exclude:
```
.terraform/
*.tfstate
*.tfstate.backup
.terraform.lock.hcl
terraform.tfvars
```

Research flags: Start with local state, migrate to S3 backend after Phase 1 (per Open Question #4).
  </action>
  <verify>
cd terraform && terraform init && terraform validate
  </verify>
  <done>
Terraform validates successfully. VPC module is syntactically correct. Variables and outputs defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Terraform RDS Aurora PostgreSQL cluster</name>
  <files>
terraform/rds.tf
  </files>
  <action>
Create Aurora PostgreSQL cluster with RDS Proxy for connection pooling.

**rds.tf:**
Create:
- aws_rds_cluster (Aurora PostgreSQL 15.x)
  - Engine: aurora-postgresql
  - Engine version: 15.4 or latest
  - Database name: iprs
  - Master username: postgres
  - Master password: from variable
  - Skip final snapshot: true (for dev)
  - DB subnet group: private subnets from VPC
  - VPC security group: allow 5432 from ECS security group

- aws_rds_cluster_instance (2 instances for HA)
  - Instance class: db.t3.medium (cost-optimized for dev)
  - Publicly accessible: false

- aws_db_proxy (RDS Proxy for connection pooling)
  - Engine family: POSTGRESQL
  - Auth: secrets manager secret for DB credentials
  - VPC subnet IDs: private subnets
  - Security group: allow from ECS

Research confirms:
- Aurora PostgreSQL is serverless-compatible but we use provisioned for cost predictability
- RDS Proxy provides connection pooling (addresses Pitfall #6: connection exhaustion)
- Secrets Manager stores DB credentials securely

Output: RDS Proxy endpoint (used by services for DATABASE_URL).
  </action>
  <verify>
cd terraform && terraform validate
  </verify>
  <done>
RDS module validates. Aurora cluster with RDS Proxy configured. Outputs include proxy endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Terraform ECS Fargate cluster and task definitions</name>
  <files>
terraform/ecs.tf
terraform/ecr.tf
  </files>
  <action>
Create ECS Fargate cluster with task definitions for all 4 services + worker.

**ecr.tf:**
Create ECR repositories:
- iprs-marketdata
- iprs-orchestrator
- iprs-results
- iprs-worker

Lifecycle policy: Keep last 10 images, expire older.

**ecs.tf:**
Create:
- aws_ecs_cluster (name: iprs-cluster)
- aws_cloudwatch_log_group (for service logs)

- Task definitions for each service (4 total):
  - Family: iprs-marketdata, iprs-orchestrator, iprs-results, iprs-worker
  - CPU: 256 (0.25 vCPU)
  - Memory: 512 MB
  - Container definitions:
    - Image: {account}.dkr.ecr.{region}.amazonaws.com/iprs-{service}:latest
    - Port mappings: 8001/8002/8003 (services only)
    - Environment variables: DATABASE_URL (from RDS Proxy), WORKER_ID
    - Log configuration: CloudWatch logs

- ECS Services (3 for REST APIs, 1 for worker):
  - Desired count: 2 (HA for services), 1 (worker)
  - Launch type: FARGATE
  - Network config: private subnets, ECS security group
  - Load balancer: attach to ALB target groups (services only)

- Application Load Balancer (ALB):
  - Subnets: public subnets
  - Security group: allow 443 from internet
  - Listener: HTTPS (certificate from ACM or self-signed for dev)
  - Target groups: one per service (health check: GET /health)

Research confirms:
- Fargate eliminates EC2 management
- ALB provides path-based routing (handled in api_gateway.tf or here)
- Auto-scaling policies can be added later

Output: ALB DNS name.
  </action>
  <verify>
cd terraform && terraform validate
  </verify>
  <done>
ECS module validates. 4 task definitions created. ECS services configured. ECR repositories defined.
  </done>
</task>

<task type="auto">
  <name>Task 4: Configure ALB path-based routing for service discovery</name>
  <files>
terraform/ecs.tf
terraform/README.md
  </files>
  <action>
Configure ALB listener rules for path-based routing to ECS services.

**ecs.tf (add to existing file from Task 3):**

Add ALB listener rules for path-based routing:
- Listener rule: /mkt/* → marketdata target group (priority 100)
- Listener rule: /orch/* → orchestrator target group (priority 200)
- Listener rule: /results/* → results target group (priority 300)
- Default rule: return 404

Example Terraform structure:
```hcl
resource "aws_lb_listener_rule" "marketdata" {
  listener_arn = aws_lb_listener.https.arn
  priority     = 100

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.marketdata.arn
  }

  condition {
    path_pattern {
      values = ["/mkt/*"]
    }
  }
}
```

Research confirms: ALB path-based routing is simpler and cheaper than API Gateway for internal API. API Gateway features (throttling, API keys, caching) not needed for MVP. Can migrate to API Gateway in Phase 2+ if needed.

**README.md:**
Document:
- How to initialize Terraform (`terraform init`)
- How to plan changes (`terraform plan`)
- How to apply (`terraform apply -var="db_master_password=..."`)
- How to destroy (`terraform destroy`)
- How to access services (ALB DNS + path prefix: https://alb-dns/mkt/*, /orch/*, /results/*)
- Local state management (migrate to S3 backend before adding team members)
- Path-based routing structure (explain /mkt, /orch, /results prefixes)

Note in README: "API Gateway deferred to Phase 2+ for advanced API management features. ALB path routing sufficient for MVP."

Research confirms: Document Terraform usage for team continuity.
  </action>
  <verify>
cd terraform && terraform validate
cat terraform/README.md | grep "terraform apply"
cat terraform/README.md | grep "ALB"
  </verify>
  <done>
ALB path-based routing configured in ecs.tf. README.md documents Terraform workflow and ALB routing structure. All modules validate.
  </done>
</task>

</tasks>

<verification>
Initialize Terraform:
```bash
cd terraform
terraform init
```

Validate all modules:
```bash
terraform validate
```

Plan infrastructure (dry run):
```bash
terraform plan -var="db_master_password=testpass123"
```

Plan should show resources to create:
- VPC, subnets, NAT, IGW
- RDS Aurora cluster + instances + proxy
- ECS cluster, task definitions, services
- ECR repositories
- ALB with target groups and listener rules for path-based routing

Do NOT apply in this plan - deployment happens in Phase 1 Plan 05 (CI/CD).

Verify README exists and is helpful:
```bash
cat terraform/README.md
```
</verification>

<success_criteria>
1. Terraform validates successfully (no syntax errors)
2. terraform plan shows all expected resources (VPC, RDS, ECS, ECR, ALB)
3. VPC with public/private subnets configured
4. Aurora PostgreSQL cluster with RDS Proxy defined
5. ECS Fargate task definitions for all 4 services + worker
6. ECR repositories created for all images
7. ALB configured with path-based routing (/mkt/*, /orch/*, /results/*)
8. README.md documents Terraform workflow and ALB routing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
