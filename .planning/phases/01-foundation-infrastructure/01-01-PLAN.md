---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/marketdata_svc/app/main.py
  - services/run_orchestrator/app/main.py
  - services/results_api/app/main.py
  - shared/config/settings.py
autonomous: true

must_haves:
  truths:
    - "All services import shared models from shared/models without local duplicates"
    - "All services use create_service_app() factory for consistent middleware"
    - "All services respond to GET /health and GET /health/deep endpoints"
    - "All services return consistent error response format"
    - "Shared config loads from environment variables with validation"
  artifacts:
    - path: "services/marketdata_svc/app/main.py"
      provides: "Marketdata service using service factory"
      min_lines: 20
      contains: "from services.common.service_base import create_service_app"
    - path: "services/run_orchestrator/app/main.py"
      provides: "Run orchestrator using service factory"
      min_lines: 200
      contains: "from services.common.service_base import create_service_app"
    - path: "services/results_api/app/main.py"
      provides: "Results API using service factory"
      min_lines: 20
      contains: "from services.common.service_base import create_service_app"
    - path: "shared/config/settings.py"
      provides: "BaseAppSettings for all services"
      exports: ["BaseAppSettings"]
  key_links:
    - from: "services/marketdata_svc/app/main.py"
      to: "services.common.service_base"
      via: "create_service_app import"
      pattern: "from services\\.common\\.service_base import create_service_app"
    - from: "services/run_orchestrator/app/main.py"
      to: "services.common.service_base"
      via: "create_service_app import"
      pattern: "from services\\.common\\.service_base import create_service_app"
    - from: "services/results_api/app/main.py"
      to: "services.common.service_base"
      via: "create_service_app import"
      pattern: "from services\\.common\\.service_base import create_service_app"
---

<objective>
Standardize all services to use shared library patterns and service factory for consistent middleware, health checks, and error handling.

Purpose: Eliminates code duplication across services and establishes consistent service patterns required for Docker and AWS deployment. PLAT-01 (shared library) and PLAT-02 (service factory) completion.

Output: All 3 services refactored to use create_service_app(), shared models, and BaseAppSettings configuration.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# Codebase context
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Existing shared library (already implemented)
@shared/config/settings.py
@services/common/service_base.py
@services/common/health.py
@services/common/errors.py
@services/common/pagination.py

# Services to refactor
@services/marketdata_svc/app/main.py
@services/run_orchestrator/app/main.py
@services/results_api/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor all three services to use create_service_app() factory</name>
  <files>
services/marketdata_svc/app/main.py
services/run_orchestrator/app/main.py
services/results_api/app/main.py
  </files>
  <action>
Replace manual FastAPI instantiation with create_service_app() from services.common.service_base.

For each service:
1. Replace `app = FastAPI(...)` with `app = create_service_app(title="...", version="0.1.0")`
2. Remove manual CORS middleware setup (factory provides this)
3. Remove manual health endpoint definitions (factory provides GET /health and GET /health/deep)
4. Keep all existing route handlers unchanged
5. Ensure imports use `from services.common.service_base import create_service_app`

Research confirms factory provides:
- CORS middleware (all origins allowed for dev)
- GET /health endpoint (returns {"ok": True})
- GET /health/deep endpoint (includes DB connectivity check)
- Standard error handlers for NotFoundError, ConflictError

Do NOT change any route handler logic. Only change service initialization.
  </action>
  <verify>
pytest -q
curl http://localhost:8001/health
curl http://localhost:8002/health
curl http://localhost:8003/health
  </verify>
  <done>
All services start successfully. Health endpoints return 200 OK with {"ok": True}. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update shared/config/settings.py to use Pydantic Settings for environment config</name>
  <files>
shared/config/settings.py
  </files>
  <action>
Extend BaseAppSettings to load environment variables with validation.

Add fields to BaseAppSettings (if not already present):
- database_url: str with default "postgresql://postgres:postgres@localhost:5432/iprs"
- worker_id: str with default "worker-1"
- worker_lease_seconds: int with default 60
- run_task_hash_mod: int with default 1
- run_task_max_attempts: int with default 3
- positions_snapshot_path: str with default "demo/inputs/positions.json"

Use Pydantic v2 patterns:
```python
from pydantic_settings import BaseSettings

class BaseAppSettings(BaseSettings):
    database_url: str = "postgresql://postgres:postgres@localhost:5432/iprs"
    worker_id: str = "worker-1"
    # ... other fields

    class Config:
        env_file = ".env"
        case_sensitive = False
```

Research confirms Pydantic Settings pattern is standard for environment config loading with validation on init.
  </action>
  <verify>
python -c "from shared.config.settings import BaseAppSettings; s = BaseAppSettings(); print(s.database_url)"
  </verify>
  <done>
BaseAppSettings loads environment variables correctly. All fields have sensible defaults. Import succeeds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Validate shared library imports work from all services</name>
  <files>
services/marketdata_svc/app/main.py
services/run_orchestrator/app/main.py
services/results_api/app/main.py
  </files>
  <action>
Add imports for shared models and verify no duplicate model definitions exist.

For each service:
1. Audit existing Pydantic model definitions in main.py
2. Check if equivalent models exist in shared/models/
3. If shared model exists, replace local definition with import from shared.models
4. If no shared model exists but model is used by multiple services, move to shared/models/

Example:
- If PositionSnapshotIn is defined locally → check shared/models/position.py
- If Currency enum is defined locally → import from shared.models.common

Research flags: "Services duplicating shared models" is Pitfall #1. Avoid by importing from shared/models/ wherever possible.

Do NOT create new shared models in this task - only replace obvious duplicates.
  </action>
  <verify>
grep -r "class.*In\|class.*Out" services/marketdata_svc/app services/run_orchestrator/app services/results_api/app | grep -v ".pyc"
python -c "from shared.models.common import Currency; print(Currency.USD)"
  </verify>
  <done>
No duplicate Pydantic models in service main.py files. All services import shared models successfully. Grep shows minimal or no local model definitions.
  </done>
</task>

</tasks>

<verification>
Run all three services locally:
```bash
uvicorn services.marketdata_svc.app.main:app --reload --port 8001 &
uvicorn services.run_orchestrator.app.main:app --reload --port 8002 &
uvicorn services.results_api.app.main:app --reload --port 8003 &
```

Verify health endpoints:
```bash
curl http://localhost:8001/health
curl http://localhost:8002/health
curl http://localhost:8003/health
curl http://localhost:8001/health/deep
```

All should return 200 OK.

Verify shared library imports:
```bash
python -c "from shared.config.settings import BaseAppSettings; from shared.models.common import Currency; print('OK')"
```

Run golden tests to ensure no regressions:
```bash
pytest compute/tests/ -q
```
</verification>

<success_criteria>
1. All three services use create_service_app() factory (verified via grep "create_service_app")
2. All services respond to GET /health and GET /health/deep (verified via curl)
3. BaseAppSettings loads environment config with validation (verified via Python import)
4. No duplicate Pydantic models in service code (verified via grep)
5. All existing tests pass (verified via pytest)
6. Services start without import errors or runtime failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
