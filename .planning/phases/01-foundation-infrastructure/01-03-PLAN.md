---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - docker/Dockerfile.marketdata
  - docker/Dockerfile.orchestrator
  - docker/Dockerfile.results
  - docker/Dockerfile.worker
  - docker/docker-compose.yml
  - .dockerignore
autonomous: true

must_haves:
  truths:
    - "All services build to Docker images successfully"
    - "Docker Compose runs all 4 services + worker locally without manual setup"
    - "Services can connect to PostgreSQL from containers"
    - "Images are optimized for size (multi-stage builds)"
  artifacts:
    - path: "docker/Dockerfile.marketdata"
      provides: "Multi-stage Dockerfile for marketdata service"
      min_lines: 20
      contains: "FROM python:3.11-slim"
    - path: "docker/Dockerfile.orchestrator"
      provides: "Multi-stage Dockerfile for orchestrator service"
      min_lines: 20
      contains: "FROM python:3.11-slim"
    - path: "docker/Dockerfile.results"
      provides: "Multi-stage Dockerfile for results service"
      min_lines: 20
      contains: "FROM python:3.11-slim"
    - path: "docker/Dockerfile.worker"
      provides: "Multi-stage Dockerfile for worker"
      min_lines: 20
      contains: "FROM python:3.11-slim"
    - path: "docker/docker-compose.yml"
      provides: "Local orchestration for all services and worker"
      min_lines: 50
      contains: "services:"
    - path: ".dockerignore"
      provides: "Docker build context exclusions"
      min_lines: 5
  key_links:
    - from: "docker/docker-compose.yml"
      to: "docker/Dockerfile.*"
      via: "build context references"
      pattern: "build:.*context.*dockerfile"
---

<objective>
Containerize all services and worker with Docker, enabling local development via Docker Compose.

Purpose: Completes PLAT-03 (Docker containerization). Establishes reproducible local environment and prepares images for ECR deployment. Research confirms multi-stage build pattern reduces image size by ~25%.

Output: All 4 services + worker containerized, Docker Compose orchestrates full stack locally.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# Codebase context
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md

# Service entry points (refactored in 01-01)
@services/marketdata_svc/app/main.py
@services/run_orchestrator/app/main.py
@services/results_api/app/main.py

# Worker entry point (refactored in 01-02)
@compute/worker/worker.py

# Database schema for reference
@sql/001_mvp_core.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfiles for all 4 services</name>
  <files>
docker/Dockerfile.marketdata
docker/Dockerfile.orchestrator
docker/Dockerfile.results
docker/Dockerfile.worker
  </files>
  <action>
Create multi-stage Dockerfiles using python:3.11-slim base.

Pattern for all services (based on research recommendations):

**Stage 1 - Builder:**
```dockerfile
FROM python:3.11-slim AS builder
WORKDIR /build
COPY pyproject.toml ./
RUN pip install --no-cache-dir build && \
    pip wheel --no-cache-dir --wheel-dir /wheels fastapi uvicorn psycopg[binary] pydantic pydantic-settings
```

**Stage 2 - Runtime:**
```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /wheels /wheels
RUN pip install --no-cache-dir /wheels/*.whl && rm -rf /wheels

COPY shared/ ./shared/
COPY services/common/ ./services/common/
COPY services/<service_name>/ ./services/<service_name>/

ENV DATABASE_URL="postgresql://postgres:postgres@db:5432/iprs"
ENV PYTHONUNBUFFERED=1

CMD ["uvicorn", "services.<service_name>.app.main:app", "--host", "0.0.0.0", "--port", "8001"]
```

For worker Dockerfile:
- Copy `compute/` directory instead of `services/`
- CMD: `["python", "-m", "compute.worker.worker"]`

Research confirms:
- Multi-stage reduces image size ~25% (273MB â†’ 208MB)
- python:3.11-slim is 120MB vs 900MB for full image
- psycopg[binary] includes C extensions for performance

Create 4 files: Dockerfile.marketdata (port 8001), Dockerfile.orchestrator (port 8002), Dockerfile.results (port 8003), Dockerfile.worker (no port).
  </action>
  <verify>
docker build -f docker/Dockerfile.marketdata -t iprs-marketdata:dev .
docker build -f docker/Dockerfile.orchestrator -t iprs-orchestrator:dev .
docker build -f docker/Dockerfile.results -t iprs-results:dev .
docker build -f docker/Dockerfile.worker -t iprs-worker:dev .
  </verify>
  <done>
All 4 Docker images build successfully. No build errors. Images tagged with :dev suffix.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose file for local development</name>
  <files>
docker/docker-compose.yml
  </files>
  <action>
Create docker-compose.yml orchestrating all services, worker, and PostgreSQL.

Services to define:
1. **db:** PostgreSQL 15 with initialized schema
   - Image: postgres:15
   - Environment: POSTGRES_PASSWORD=postgres, POSTGRES_DB=iprs
   - Volume: ./sql/001_mvp_core.sql mounted for schema init
   - Healthcheck: pg_isready

2. **marketdata:** Marketdata service
   - Build: ./docker/Dockerfile.marketdata
   - Ports: 8001:8001
   - Depends on: db (wait for healthy)
   - Environment: DATABASE_URL=postgresql://postgres:postgres@db:5432/iprs

3. **orchestrator:** Run orchestrator service
   - Build: ./docker/Dockerfile.orchestrator
   - Ports: 8002:8002
   - Depends on: db
   - Environment: DATABASE_URL, POSITIONS_SNAPSHOT_PATH=/app/demo/inputs/positions.json
   - Volume: ./demo mounted for positions file

4. **results:** Results API service
   - Build: ./docker/Dockerfile.results
   - Ports: 8003:8003
   - Depends on: db

5. **worker:** Distributed task worker
   - Build: ./docker/Dockerfile.worker
   - Depends on: db, orchestrator
   - Environment: DATABASE_URL, WORKER_ID=worker-compose-1

Research confirms:
- Healthcheck ensures db is ready before services start
- Shared network allows service-to-service DNS resolution
- Volume mounts enable live code reload during development (optional)

Use version: '3.8' for compose file format.
  </action>
  <verify>
docker-compose -f docker/docker-compose.yml config
  </verify>
  <done>
Docker Compose file validates successfully. Config shows all 5 services with correct dependencies and environment variables.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create .dockerignore to optimize build context</name>
  <files>
.dockerignore
  </files>
  <action>
Create .dockerignore to exclude unnecessary files from Docker build context.

Exclude patterns:
```
**/__pycache__
**/*.pyc
**/*.pyo
**/*.pyd
.pytest_cache
.mypy_cache
.venv
venv
*.egg-info
.git
.gitignore
node_modules
frontend/dist
frontend/node_modules
.planning
README.md
*.md
.env
.DS_Store
```

Research confirms:
- Reduces build context size (faster uploads to Docker daemon)
- Prevents sensitive files (.env) from being included in image layers
- Excludes frontend artifacts (not needed in backend images)

Place at project root (same level as docker/ directory).
  </action>
  <verify>
docker build -f docker/Dockerfile.marketdata -t iprs-marketdata:test . 2>&1 | grep "Sending build context"
  </verify>
  <done>
.dockerignore exists. Build context size is reasonable (<50MB). Sensitive files excluded from build.
  </done>
</task>

</tasks>

<verification>
Build all images:
```bash
docker-compose -f docker/docker-compose.yml build
```

Start full stack:
```bash
docker-compose -f docker/docker-compose.yml up -d
```

Wait for services to be healthy:
```bash
docker-compose -f docker/docker-compose.yml ps
```

Verify health endpoints from host:
```bash
curl http://localhost:8001/health
curl http://localhost:8002/health
curl http://localhost:8003/health
```

All should return 200 OK.

Check logs for startup errors:
```bash
docker-compose -f docker/docker-compose.yml logs
```

Tear down:
```bash
docker-compose -f docker/docker-compose.yml down
```
</verification>

<success_criteria>
1. All 4 Dockerfiles build successfully (verified via docker build)
2. Docker Compose orchestrates full stack (5 containers: db + 3 services + worker)
3. All services respond to health checks from host (verified via curl)
4. Services can connect to PostgreSQL (verified via health/deep endpoints)
5. Build context optimized via .dockerignore (verified via build output)
6. Images use multi-stage builds for size optimization (verified via docker images)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
