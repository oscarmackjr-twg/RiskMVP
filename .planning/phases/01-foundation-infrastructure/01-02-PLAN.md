---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - compute/worker/worker.py
autonomous: true

must_haves:
  truths:
    - "Worker dispatches to pricers via registry, not if/elif chain"
    - "Adding new pricer requires no worker.py modification"
    - "All 3 existing pricers (FX_FWD, AMORT_LOAN, FIXED_BOND) work via registry"
  artifacts:
    - path: "compute/worker/worker.py"
      provides: "Worker using registry pattern for pricer dispatch"
      min_lines: 200
      contains: "from compute.pricers.registry import get_pricer"
    - path: "compute/pricers/registry.py"
      provides: "Pricer registry with 3 registered pricers"
      exports: ["register", "get_pricer", "registered_types"]
  key_links:
    - from: "compute/worker/worker.py"
      to: "compute.pricers.registry.get_pricer"
      via: "registry lookup by product_type"
      pattern: "get_pricer\\(.*product_type"
    - from: "compute/pricers/fx_fwd.py"
      to: "compute.pricers.registry.register"
      via: "auto-registration on import"
      pattern: "register\\(\"FX_FWD\""
---

<objective>
Refactor worker to use existing pricer registry pattern, eliminating if/elif dispatch chain.

Purpose: Completes PLAT-06 (pricer registry pattern). Enables adding new pricers without modifying worker.py. Research confirms registry is already fully implemented - just needs worker refactoring.

Output: Worker dispatches all pricing tasks via registry.get_pricer(product_type).
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# Codebase context
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Registry (already implemented)
@compute/pricers/registry.py
@compute/pricers/base.py

# Existing pricers (already registered)
@compute/pricers/fx_fwd.py
@compute/pricers/bond.py
@compute/pricers/loan.py

# Worker to refactor
@compute/worker/worker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace if/elif dispatch in worker.py with registry lookup</name>
  <files>
compute/worker/worker.py
  </files>
  <action>
Refactor price_position() dispatch logic to use registry pattern.

Current code (lines 184-190 per research):
```python
if product_type == "FX_FWD":
    return price_fx_fwd(...)
elif product_type == "AMORT_LOAN":
    return price_loan(...)
elif product_type == "FIXED_BOND":
    return price_bond(...)
else:
    raise ValueError(f"Unknown product_type: {product_type}")
```

Replace with:
```python
from compute.pricers.registry import get_pricer

pricer_fn = get_pricer(task.product_type)  # Raises ValueError if not registered
measures = pricer_fn(position, instrument, market_snapshot, measures, scenario_id)
```

Research confirms:
- Registry pattern fully implemented in compute/pricers/registry.py
- All 3 pricers already registered via register() calls
- get_pricer() raises ValueError if product_type not registered
- Registry bootstrap happens on module import via _bootstrap()

Remove individual pricer imports (price_fx_fwd, price_bond, price_loan) after refactoring. Import only registry.get_pricer.
  </action>
  <verify>
pytest compute/tests/test_fx_fwd_golden.py -q
pytest compute/tests/test_bond_golden.py -q
pytest compute/tests/test_loan_golden.py -q
python -c "from compute.pricers.registry import registered_types; print(registered_types())"
  </verify>
  <done>
Worker uses registry.get_pricer() for all pricer dispatch. All golden tests pass. registered_types() returns ["FX_FWD", "AMORT_LOAN", "FIXED_BOND"].
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test for registry pattern in worker</name>
  <files>
compute/tests/test_worker_registry.py
  </files>
  <action>
Create new test file to verify registry integration in worker.

Test cases:
1. test_all_pricers_registered: Verify FX_FWD, AMORT_LOAN, FIXED_BOND are in registered_types()
2. test_unknown_product_type_raises: Verify get_pricer("UNKNOWN") raises ValueError with descriptive message
3. test_registry_bootstrap_on_import: Import compute.pricers.registry and verify bootstrap ran

Example test structure:
```python
from compute.pricers.registry import registered_types, get_pricer
import pytest

def test_all_pricers_registered():
    types = registered_types()
    assert "FX_FWD" in types
    assert "AMORT_LOAN" in types
    assert "FIXED_BOND" in types

def test_unknown_product_type_raises():
    with pytest.raises(ValueError, match="No pricer registered"):
        get_pricer("UNKNOWN_TYPE")
```

Research confirms this addresses Pitfall #3: "Registry Pattern Initialization Order Dependency". Test validates bootstrap worked.
  </action>
  <verify>
pytest compute/tests/test_worker_registry.py -v
  </verify>
  <done>
New test file exists. All 3 tests pass. Registry bootstrap verified.
  </done>
</task>

</tasks>

<verification>
Run worker with registry pattern:
```bash
python -m compute.worker.worker
```

Worker should start without import errors. Stop after confirming startup.

Run all golden tests (end-to-end pricer validation):
```bash
pytest compute/tests/ -v
```

All tests should pass, confirming pricers work via registry.

Verify registry state:
```python
python -c "from compute.pricers.registry import registered_types; print(sorted(registered_types()))"
```

Should output: ['AMORT_LOAN', 'FIXED_BOND', 'FX_FWD']
</verification>

<success_criteria>
1. Worker uses registry.get_pricer() instead of if/elif chain (verified via code inspection)
2. All 3 existing pricers registered and functional (verified via registered_types())
3. All golden tests pass (verified via pytest)
4. Unknown product types raise clear ValueError (verified via test)
5. Worker can be extended with new pricers without modifying worker.py (demonstrated by registry pattern)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
