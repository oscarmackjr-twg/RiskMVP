---
phase: 03-portfolio-data-services
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - services/portfolio_svc/app/routes/portfolios.py
  - services/portfolio_svc/app/routes/positions.py
  - services/portfolio_svc/app/routes/tags.py
  - services/portfolio_svc/app/models.py
  - services/common/portfolio_queries.py
autonomous: true

must_haves:
  truths:
    - "User can create portfolio hierarchy (fund → desk → book)"
    - "User can add positions to portfolio nodes"
    - "User can view full hierarchy tree with position counts"
    - "User can query direct children of a portfolio node"
    - "User can tag portfolios and positions for segmentation"
  artifacts:
    - path: "services/portfolio_svc/app/routes/portfolios.py"
      provides: "Portfolio CRUD and hierarchy tree queries"
      exports: ["create_portfolio", "get_portfolio_tree"]
    - path: "services/portfolio_svc/app/routes/positions.py"
      provides: "Position CRUD and linking to instruments"
      exports: ["create_position", "list_positions"]
    - path: "services/common/portfolio_queries.py"
      provides: "Recursive CTE query builder for hierarchy"
      exports: ["build_hierarchy_tree_query"]
  key_links:
    - from: "services/portfolio_svc/app/routes/portfolios.py"
      to: "sql/002_portfolio_data_services.sql portfolio_node table"
      via: "INSERT/SELECT queries with db_conn()"
      pattern: "WITH RECURSIVE hierarchy"
    - from: "services/portfolio_svc/app/routes/positions.py"
      to: "sql/001_mvp_core.sql instrument table"
      via: "Foreign key validation on instrument_id"
      pattern: "REFERENCES instrument"
---

<objective>
Implement portfolio hierarchy management and position tracking. Enable users to create multi-level portfolio structures, add positions linked to instruments, and query the full tree with aggregated metrics.

Purpose: Core portfolio domain for Phase 3; enables drill-down analytics and position aggregation.
Output: Working portfolio service with CRUD operations, recursive hierarchy queries, and position management.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-portfolio-data-services/03-RESEARCH.md
@.planning/phases/03-portfolio-data-services/03-01-SUMMARY.md

# Database schema
@sql/002_portfolio_data_services.sql

# Service scaffolding
@services/portfolio_svc/app/main.py
@services/portfolio_svc/app/routes/portfolios.py
@services/portfolio_svc/app/routes/positions.py
@services/portfolio_svc/app/routes/tags.py
@services/portfolio_svc/app/models.py

# Shared utilities
@services/common/db.py
@services/common/service_base.py
@services/common/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement portfolio CRUD and hierarchy tree queries</name>
  <files>
services/portfolio_svc/app/routes/portfolios.py
services/common/portfolio_queries.py
  </files>
  <action>
Replace stub implementations in portfolios.py with working endpoints using PostgreSQL recursive CTEs for hierarchy queries.

**portfolios.py endpoints:**

1. `POST /api/v1/portfolios` - Create portfolio node
   - Accept PortfolioCreate (name, parent_id, node_type, tags_json, metadata_json)
   - Generate portfolio_node_id = f"port-{uuid4()}"
   - INSERT INTO portfolio_node with validation on parent_id existence
   - Return PortfolioOut with created node

2. `GET /api/v1/portfolios` - List all root portfolios (parent_id IS NULL)
   - SELECT * FROM portfolio_node WHERE parent_id IS NULL
   - Return List[PortfolioOut]

3. `GET /api/v1/portfolios/{portfolio_id}` - Get single portfolio
   - SELECT * FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Raise 404 if not found
   - Return PortfolioOut

4. `PATCH /api/v1/portfolios/{portfolio_id}` - Update portfolio
   - Accept PortfolioUpdate (name, tags_json, metadata_json - all optional)
   - UPDATE portfolio_node SET ... WHERE portfolio_node_id = %(pid)s
   - Return updated PortfolioOut

5. `DELETE /api/v1/portfolios/{portfolio_id}` - Delete portfolio
   - Check for children: SELECT count(*) FROM portfolio_node WHERE parent_id = %(pid)s
   - If children exist, raise 400 "Cannot delete portfolio with children"
   - Check for positions: SELECT count(*) FROM position WHERE portfolio_node_id = %(pid)s
   - If positions exist, raise 400 "Cannot delete portfolio with positions"
   - DELETE FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Return 204 No Content

6. `GET /api/v1/portfolios/{portfolio_id}/tree` - Get full hierarchy tree
   - Use recursive CTE to fetch entire tree rooted at portfolio_id
   - Join to position table for position_count per node
   - Join to valuation_result for PV aggregation (optional run_id param)
   - Call build_hierarchy_tree_query() helper from portfolio_queries.py
   - Convert flat rows to nested PortfolioTreeNode structure in Python
   - Return PortfolioTreeNode with recursive children

7. `GET /api/v1/portfolios/{portfolio_id}/children` - Get direct children
   - SELECT * FROM portfolio_node WHERE parent_id = %(pid)s
   - Return List[PortfolioOut]

8. `POST /api/v1/portfolios/{portfolio_id}/reparent` - Move portfolio under new parent
   - Accept new_parent_id in request body
   - Validate new parent exists and is not descendant of current node (prevent cycles)
   - UPDATE portfolio_node SET parent_id = %(new_pid)s WHERE portfolio_node_id = %(pid)s
   - Return updated PortfolioOut

**portfolio_queries.py helper:**
Create build_hierarchy_tree_query(portfolio_id, run_id=None) function returning SQL string with recursive CTE.

Pattern from research (03-RESEARCH.md line 113-156):
```sql
WITH RECURSIVE hierarchy AS (
  SELECT portfolio_node_id, name, parent_id, node_type, 1 AS depth,
         CAST(portfolio_node_id AS text) AS tree_path
  FROM portfolio_node WHERE portfolio_node_id = %(pid)s
  UNION ALL
  SELECT pn.portfolio_node_id, pn.name, pn.parent_id, pn.node_type, h.depth + 1,
         h.tree_path || '/' || pn.portfolio_node_id
  FROM portfolio_node pn
  INNER JOIN hierarchy h ON pn.parent_id = h.portfolio_node_id
  WHERE h.depth < 10
)
SELECT h.*, COUNT(DISTINCT pos.position_id) AS position_count,
       COALESCE(SUM((vr.measures_json ->> 'PV')::numeric), 0) AS pv_sum
FROM hierarchy h
LEFT JOIN position pos ON h.portfolio_node_id = pos.portfolio_node_id
LEFT JOIN valuation_result vr ON pos.position_id = vr.position_id
  AND (%(rid)s IS NULL OR vr.run_id = %(rid)s)
  AND vr.scenario_id = 'BASE'
GROUP BY h.portfolio_node_id, h.name, h.parent_id, h.node_type, h.depth, h.tree_path
ORDER BY h.tree_path;
```

Use db_conn() context manager for all queries. Handle exceptions with try/except, raise HTTPException(500) on database errors.
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Test create root portfolio
curl -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Fund", "node_type": "FUND"}' | jq .

# Test create child portfolio
PARENT_ID=$(curl -s http://localhost:8004/api/v1/portfolios | jq -r '.[0].portfolio_node_id')
curl -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d "{\"name\": \"Test Desk\", \"node_type\": \"DESK\", \"parent_id\": \"$PARENT_ID\"}" | jq .

# Test hierarchy tree
curl -s http://localhost:8004/api/v1/portfolios/$PARENT_ID/tree | jq .

# Clean up
pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Portfolio CRUD endpoints working. Hierarchy tree query returns nested structure with position counts. Direct children query works. Reparent prevents cycles. All endpoints return proper HTTP status codes and error messages.</done>
</task>

<task type="auto">
  <name>Task 2: Implement position CRUD and instrument linking</name>
  <files>services/portfolio_svc/app/routes/positions.py</files>
  <action>
Replace stub implementations in positions.py with working endpoints for position management.

**positions.py endpoints:**

1. `POST /api/v1/positions` - Create position
   - Accept PositionCreate (portfolio_node_id, instrument_id, quantity, base_ccy, cost_basis, book_value, tags_json)
   - Validate portfolio_node_id exists: SELECT 1 FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Validate instrument_id exists: SELECT 1 FROM instrument WHERE instrument_id = %(iid)s
   - If either missing, raise 404 with descriptive message
   - Generate position_id = f"pos-{uuid4()}"
   - INSERT INTO position with status='ACTIVE', created_at=now()
   - Return PositionOut with created position

2. `GET /api/v1/positions` - List positions with filtering
   - Accept query params: portfolio_node_id, instrument_id, status, limit, offset
   - Build WHERE clause dynamically based on provided filters
   - SELECT * FROM position WHERE <filters> ORDER BY created_at DESC LIMIT %(lim)s OFFSET %(off)s
   - Return List[PositionOut]

3. `GET /api/v1/positions/{position_id}` - Get single position
   - SELECT * FROM position WHERE position_id = %(pid)s
   - Raise 404 if not found
   - Return PositionOut

4. `PATCH /api/v1/positions/{position_id}` - Update position
   - Accept PositionUpdate (quantity, cost_basis, book_value, tags_json, status - all optional)
   - UPDATE position SET ..., updated_at=now() WHERE position_id = %(pid)s
   - Return updated PositionOut

5. `DELETE /api/v1/positions/{position_id}` - Soft delete position
   - UPDATE position SET status='DELETED', updated_at=now() WHERE position_id = %(pid)s
   - Return 204 No Content

6. `GET /api/v1/positions/{position_id}/valuation` - Get latest valuation for position
   - SELECT * FROM valuation_result WHERE position_id = %(pid)s ORDER BY run_id DESC LIMIT 1
   - Join to run table for as_of_time
   - Return valuation with measures_json

7. `GET /api/v1/positions/by-portfolio/{portfolio_node_id}` - List positions for portfolio
   - SELECT * FROM position WHERE portfolio_node_id = %(pid)s AND status='ACTIVE'
   - Join to instrument table for instrument details
   - Return List[PositionOut] with instrument metadata

Use db_conn() for all queries. Validate foreign keys before INSERT to provide helpful error messages. Handle constraint violations gracefully.
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create test instrument (assumes instrument table exists from Phase 1)
psql $DATABASE_URL -c "INSERT INTO instrument (instrument_id, instrument_type) VALUES ('test-instr-1', 'LOAN') ON CONFLICT DO NOTHING;"

# Create test portfolio
PORT_ID=$(curl -s -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Portfolio", "node_type": "BOOK"}' | jq -r '.portfolio_node_id')

# Create position
curl -X POST http://localhost:8004/api/v1/positions \
  -H "Content-Type: application/json" \
  -d "{\"portfolio_node_id\": \"$PORT_ID\", \"instrument_id\": \"test-instr-1\", \"quantity\": 1000000, \"base_ccy\": \"USD\", \"cost_basis\": 1000000, \"book_value\": 1000000}" | jq .

# List positions
curl -s http://localhost:8004/api/v1/positions | jq .

# Clean up
pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Position CRUD endpoints working. Foreign key validation provides helpful errors. Positions link correctly to portfolios and instruments. Soft delete preserves data. Valuation endpoint returns latest results.</done>
</task>

<task type="auto">
  <name>Task 3: Implement portfolio and position tagging</name>
  <files>services/portfolio_svc/app/routes/tags.py</files>
  <action>
Replace stub implementations in tags.py with working endpoints for segmentation and tagging.

**tags.py endpoints:**

1. `POST /api/v1/tags/portfolio/{portfolio_id}` - Add tags to portfolio
   - Accept TagUpdate (tags: List[str])
   - Merge new tags with existing tags_json in portfolio_node
   - UPDATE portfolio_node SET tags_json = tags_json || %(new_tags)s::jsonb WHERE portfolio_node_id = %(pid)s
   - Return updated portfolio with merged tags

2. `DELETE /api/v1/tags/portfolio/{portfolio_id}` - Remove tags from portfolio
   - Accept TagUpdate (tags: List[str])
   - Remove specified tags from tags_json
   - UPDATE portfolio_node SET tags_json = tags_json - %(tags_to_remove)s WHERE portfolio_node_id = %(pid)s
   - Return updated portfolio

3. `GET /api/v1/tags/portfolio` - List all portfolios with specific tag
   - Accept query param: tag (required)
   - SELECT * FROM portfolio_node WHERE tags_json ? %(tag)s
   - Return List[PortfolioOut]

4. `POST /api/v1/tags/position/{position_id}` - Add tags to position
   - Same pattern as portfolio tagging
   - UPDATE position table

5. `DELETE /api/v1/tags/position/{position_id}` - Remove tags from position
   - Same pattern as portfolio tag removal

6. `GET /api/v1/tags/position` - List all positions with specific tag
   - SELECT * FROM position WHERE tags_json ? %(tag)s AND status='ACTIVE'

7. `GET /api/v1/tags/all` - List all unique tags across portfolios and positions
   - SELECT DISTINCT jsonb_object_keys(tags_json) AS tag FROM portfolio_node
   - UNION with position table
   - Return List[str] of unique tags

Use PostgreSQL JSONB operators: `||` for merge, `-` for removal, `?` for existence check. Handle NULL tags_json gracefully (initialize to empty object if NULL).
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create test portfolio
PORT_ID=$(curl -s -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d '{"name": "Tagged Portfolio", "node_type": "BOOK"}' | jq -r '.portfolio_node_id')

# Add tags
curl -X POST http://localhost:8004/api/v1/tags/portfolio/$PORT_ID \
  -H "Content-Type: application/json" \
  -d '{"tags": ["high-yield", "energy-sector"]}' | jq .

# Query by tag
curl -s "http://localhost:8004/api/v1/tags/portfolio?tag=high-yield" | jq .

# List all tags
curl -s http://localhost:8004/api/v1/tags/all | jq .

# Clean up
pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Tagging endpoints working for both portfolios and positions. JSONB merge/remove operations handle NULL values. Tag queries filter correctly. All unique tags queryable across both tables.</done>
</task>

</tasks>

<verification>
**Portfolio Management:**
- [ ] Create portfolio nodes with parent-child relationships
- [ ] List root portfolios and direct children
- [ ] Update portfolio metadata (name, tags, metadata_json)
- [ ] Delete portfolios with validation (no children, no positions)
- [ ] Reparent prevents cycles in hierarchy

**Hierarchy Queries:**
- [ ] Recursive CTE returns full tree structure
- [ ] Position counts aggregate correctly per node
- [ ] PV sums work when run_id provided
- [ ] Tree depth limited to prevent runaway recursion
- [ ] Nested tree structure built correctly in Python

**Position Management:**
- [ ] Create positions linked to portfolios and instruments
- [ ] Foreign key validation provides helpful errors
- [ ] List positions with filtering by portfolio, instrument, status
- [ ] Update position quantities and metadata
- [ ] Soft delete preserves position data
- [ ] Latest valuation queryable per position

**Tagging:**
- [ ] Add/remove tags for portfolios and positions
- [ ] JSONB operations handle NULL values
- [ ] Query entities by tag
- [ ] List all unique tags across both tables
</verification>

<success_criteria>
**Portfolio hierarchy and position management complete when:**
- User can create multi-level hierarchy (fund → desk → book) via API
- Hierarchy tree query returns nested structure with metrics in <1 second
- Positions link to instruments with foreign key validation
- Position CRUD operations work with filtering and pagination
- Tags enable portfolio segmentation and filtering
- All endpoints return proper HTTP status codes and error messages
</success_criteria>

<output>
After completion, create `.planning/phases/03-portfolio-data-services/03-02-SUMMARY.md` documenting:
- Endpoints implemented with example curl commands
- Recursive CTE performance characteristics
- Foreign key validation strategy
- Tag query patterns
</output>
