---
phase: 03-portfolio-data-services
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - services/portfolio_svc/app/routes/portfolios.py
  - services/portfolio_svc/app/routes/positions.py
  - services/portfolio_svc/app/routes/tags.py
  - services/portfolio_svc/app/routes/instruments.py
  - services/portfolio_svc/app/models.py
  - services/common/portfolio_queries.py
autonomous: true

must_haves:
  truths:
    - "User can create portfolio hierarchy (fund → desk → book)"
    - "User can add positions to portfolio nodes"
    - "User can view full hierarchy tree with position counts"
    - "User can query direct children of a portfolio node"
    - "User can tag portfolios and positions for segmentation"
    - "User can create/update/delete instruments via API"
  artifacts:
    - path: "services/portfolio_svc/app/routes/portfolios.py"
      provides: "Portfolio CRUD and hierarchy tree queries"
      exports: ["create_portfolio", "get_portfolio_tree"]
    - path: "services/portfolio_svc/app/routes/positions.py"
      provides: "Position CRUD and linking to instruments"
      exports: ["create_position", "list_positions"]
    - path: "services/portfolio_svc/app/routes/instruments.py"
      provides: "Instrument master CRUD endpoints"
      exports: ["create_instrument", "update_instrument", "list_instruments"]
    - path: "services/common/portfolio_queries.py"
      provides: "Recursive CTE query builder for hierarchy"
      exports: ["build_hierarchy_tree_query"]
  key_links:
    - from: "services/portfolio_svc/app/routes/portfolios.py"
      to: "sql/002_portfolio_data_services.sql portfolio_node table"
      via: "INSERT/SELECT queries with db_conn()"
      pattern: "WITH RECURSIVE hierarchy"
    - from: "services/portfolio_svc/app/routes/positions.py"
      to: "sql/001_mvp_core.sql instrument table"
      via: "Foreign key validation on instrument_id"
      pattern: "REFERENCES instrument"
    - from: "services/portfolio_svc/app/routes/instruments.py"
      to: "sql/001_mvp_core.sql instrument table"
      via: "INSERT/UPDATE on instrument and instrument_version"
      pattern: "INSERT INTO instrument"
---

<objective>
Implement portfolio hierarchy management, position tracking, and instrument master CRUD. Enable users to create multi-level portfolio structures, manage instrument metadata, add positions linked to instruments, and query the full tree with aggregated metrics.

Purpose: Core portfolio domain for Phase 3; enables drill-down analytics, position aggregation, and instrument lifecycle management.
Output: Working portfolio service with CRUD operations, recursive hierarchy queries, position management, and instrument master endpoints.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-portfolio-data-services/03-RESEARCH.md
@.planning/phases/03-portfolio-data-services/03-01-SUMMARY.md

# Database schema
@sql/002_portfolio_data_services.sql
@sql/001_mvp_core.sql

# Service scaffolding
@services/portfolio_svc/app/main.py
@services/portfolio_svc/app/routes/portfolios.py
@services/portfolio_svc/app/routes/positions.py
@services/portfolio_svc/app/routes/tags.py
@services/portfolio_svc/app/routes/instruments.py
@services/portfolio_svc/app/models.py

# Shared utilities
@services/common/db.py
@services/common/service_base.py
@services/common/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement instrument master CRUD endpoints</name>
  <files>
services/portfolio_svc/app/routes/instruments.py
services/portfolio_svc/app/main.py
  </files>
  <action>
Create new instruments.py route module for instrument master CRUD operations (PORT-01 requirement).

**instruments.py endpoints:**

1. `POST /api/v1/instruments` - Create instrument
   - Accept InstrumentCreate (instrument_type, terms_json, tags_json)
   - Validate: instrument_type IN ('LOAN', 'FIXED_BOND', 'FLOATING_BOND', 'CALLABLE_BOND', 'PUTABLE_BOND', 'ABS', 'MBS', 'FX_FWD', 'FX_SWAP', 'IRS', 'CDS', 'OPTION', 'FUTURE')
   - Generate instrument_id = f"{instrument_type.lower()}-{uuid4()}"
   - INSERT INTO instrument:
     ```sql
     INSERT INTO instrument (instrument_id, instrument_type, created_at)
     VALUES (%(iid)s, %(itype)s, now())
     RETURNING instrument_id;
     ```
   - Create initial instrument_version (version=1, status='APPROVED'):
     ```sql
     INSERT INTO instrument_version
       (instrument_id, version, terms_json, status, created_at, updated_at)
     VALUES (%(iid)s, 1, %(terms)s::jsonb, 'APPROVED', now(), now());
     ```
   - Return InstrumentOut (instrument_id, instrument_type, version=1, terms_json)

2. `GET /api/v1/instruments` - List instruments with filtering
   - Accept query params: instrument_type, tags, search (instrument_id/issuer), limit, offset
   - Build WHERE clause dynamically:
     ```sql
     SELECT i.instrument_id, i.instrument_type, iv.version, iv.terms_json, iv.status
     FROM instrument i
     INNER JOIN instrument_version iv ON i.instrument_id = iv.instrument_id
       AND iv.status = 'APPROVED'
     WHERE (%(itype)s IS NULL OR i.instrument_type = %(itype)s)
       AND (%(search)s IS NULL OR i.instrument_id ILIKE %(search)s
            OR iv.terms_json ->> 'issuer_id' ILIKE %(search)s)
     ORDER BY i.created_at DESC
     LIMIT %(lim)s OFFSET %(off)s;
     ```
   - Return List[InstrumentOut]

3. `GET /api/v1/instruments/{instrument_id}` - Get single instrument
   - SELECT with JOIN to instrument_version for APPROVED version
   - Return InstrumentOut with full terms_json or 404

4. `PATCH /api/v1/instruments/{instrument_id}` - Update instrument
   - Accept InstrumentUpdate (terms_json - partial update)
   - Get current APPROVED version
   - Create new instrument_version with incremented version number:
     ```sql
     INSERT INTO instrument_version
       (instrument_id, version, terms_json, status, created_at, updated_at)
     SELECT instrument_id, MAX(version) + 1,
            %(new_terms)s::jsonb, 'APPROVED', now(), now()
     FROM instrument_version
     WHERE instrument_id = %(iid)s
     GROUP BY instrument_id;
     ```
   - Mark old version as SUPERSEDED (optional - or leave as APPROVED for audit trail)
   - Return updated InstrumentOut with new version number
   - NOTE: Instrument versioning (DATA-03) scope is BASIC for Phase 3 - just version number tracking and APPROVED status. Full version workflow (DRAFT, PENDING_APPROVAL, REJECTED) deferred to future phase.

5. `DELETE /api/v1/instruments/{instrument_id}` - Retire instrument
   - Check for active positions:
     ```sql
     SELECT count(*) FROM position WHERE instrument_id = %(iid)s AND status='ACTIVE';
     ```
   - If positions exist, raise 400 "Cannot delete instrument with active positions. Retire instead."
   - UPDATE instrument_version SET status='RETIRED' for all versions
   - Return 204 No Content

6. `POST /api/v1/instruments/bulk-create` - Bulk instrument creation
   - Accept BulkInstrumentCreate (instruments: List[InstrumentCreate])
   - Validate all instruments in batch
   - INSERT in transaction (all or nothing)
   - Return BulkCreateResult (created_count, errors: List[{index, error}])

7. `GET /api/v1/instruments/{instrument_id}/versions` - Get version history
   - SELECT * FROM instrument_version WHERE instrument_id = %(iid)s ORDER BY version DESC
   - Return List[InstrumentVersionOut]

Add router to main.py:
```python
from services.portfolio_svc.app.routes.instruments import router as instruments_router
app.include_router(instruments_router, prefix="/api/v1/instruments", tags=["instruments"])
```

Use db_conn() for all queries. Handle constraint violations (duplicate instrument_id unlikely due to UUID, but check instrument_type enum). For terms_json validation, accept any valid JSON for MVP - add JSON schema validation in future phase if needed.

**Important:** This completes PORT-01 requirement for instrument master CRUD. Scope is basic version tracking only (DATA-03 clarification: version number and APPROVED/RETIRED status, no workflow).
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create loan instrument
curl -X POST http://localhost:8004/api/v1/instruments \
  -H "Content-Type: application/json" \
  -d '{
    "instrument_type": "LOAN",
    "terms_json": {
      "issuer_id": "issuer-1",
      "notional": 1000000,
      "currency": "USD",
      "maturity_date": "2030-12-31",
      "coupon_rate": 0.05
    }
  }' | jq .

# List instruments
curl -s http://localhost:8004/api/v1/instruments | jq .

# Update instrument (creates new version)
INSTR_ID=$(curl -s http://localhost:8004/api/v1/instruments | jq -r '.[0].instrument_id')
curl -X PATCH http://localhost:8004/api/v1/instruments/$INSTR_ID \
  -H "Content-Type: application/json" \
  -d '{"terms_json": {"coupon_rate": 0.055}}' | jq .

# Check version history
curl -s http://localhost:8004/api/v1/instruments/$INSTR_ID/versions | jq .

pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Instrument master CRUD endpoints working. Create/update/delete/list operations functional. Bulk creation handles batch uploads. Version history tracked with APPROVED/RETIRED status. Foreign key validation on positions prevents deletion of used instruments. PORT-01 requirement complete.</done>
</task>

<task type="auto">
  <name>Task 2: Implement portfolio CRUD and hierarchy tree queries</name>
  <files>
services/portfolio_svc/app/routes/portfolios.py
services/common/portfolio_queries.py
  </files>
  <action>
Replace stub implementations in portfolios.py with working endpoints using PostgreSQL recursive CTEs for hierarchy queries.

**portfolios.py endpoints:**

1. `POST /api/v1/portfolios` - Create portfolio node
   - Accept PortfolioCreate (name, parent_id, node_type, tags_json, metadata_json)
   - Generate portfolio_node_id = f"port-{uuid4()}"
   - INSERT INTO portfolio_node with validation on parent_id existence
   - Return PortfolioOut with created node

2. `GET /api/v1/portfolios` - List all root portfolios (parent_id IS NULL)
   - SELECT * FROM portfolio_node WHERE parent_id IS NULL
   - Return List[PortfolioOut]

3. `GET /api/v1/portfolios/{portfolio_id}` - Get single portfolio
   - SELECT * FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Raise 404 if not found
   - Return PortfolioOut

4. `PATCH /api/v1/portfolios/{portfolio_id}` - Update portfolio
   - Accept PortfolioUpdate (name, tags_json, metadata_json - all optional)
   - UPDATE portfolio_node SET ... WHERE portfolio_node_id = %(pid)s
   - Return updated PortfolioOut

5. `DELETE /api/v1/portfolios/{portfolio_id}` - Delete portfolio
   - Check for children: SELECT count(*) FROM portfolio_node WHERE parent_id = %(pid)s
   - If children exist, raise 400 "Cannot delete portfolio with children"
   - Check for positions: SELECT count(*) FROM position WHERE portfolio_node_id = %(pid)s
   - If positions exist, raise 400 "Cannot delete portfolio with positions"
   - DELETE FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Return 204 No Content

6. `GET /api/v1/portfolios/{portfolio_id}/tree` - Get full hierarchy tree
   - Use recursive CTE to fetch entire tree rooted at portfolio_id
   - Join to position table for position_count per node
   - Join to valuation_result for PV aggregation (optional run_id param)
   - Call build_hierarchy_tree_query() helper from portfolio_queries.py
   - Convert flat rows to nested PortfolioTreeNode structure in Python
   - Return PortfolioTreeNode with recursive children
   - **NOTE:** PV aggregations require Phase 2 valuation_result data. Endpoint works but shows 0 PV until run results available. Document in response or logs if no valuation data found.

7. `GET /api/v1/portfolios/{portfolio_id}/children` - Get direct children
   - SELECT * FROM portfolio_node WHERE parent_id = %(pid)s
   - Return List[PortfolioOut]

8. `POST /api/v1/portfolios/{portfolio_id}/reparent` - Move portfolio under new parent
   - Accept new_parent_id in request body
   - Validate new parent exists and is not descendant of current node (prevent cycles)
   - UPDATE portfolio_node SET parent_id = %(new_pid)s WHERE portfolio_node_id = %(pid)s
   - Return updated PortfolioOut

**portfolio_queries.py helper:**
Create build_hierarchy_tree_query(portfolio_id, run_id=None) function returning SQL string with recursive CTE.

Pattern from research (03-RESEARCH.md line 113-156):
```sql
WITH RECURSIVE hierarchy AS (
  SELECT portfolio_node_id, name, parent_id, node_type, 1 AS depth,
         CAST(portfolio_node_id AS text) AS tree_path
  FROM portfolio_node WHERE portfolio_node_id = %(pid)s
  UNION ALL
  SELECT pn.portfolio_node_id, pn.name, pn.parent_id, pn.node_type, h.depth + 1,
         h.tree_path || '/' || pn.portfolio_node_id
  FROM portfolio_node pn
  INNER JOIN hierarchy h ON pn.parent_id = h.portfolio_node_id
  WHERE h.depth < 10
)
SELECT h.*, COUNT(DISTINCT pos.position_id) AS position_count,
       COALESCE(SUM((vr.measures_json ->> 'PV')::numeric), 0) AS pv_sum
FROM hierarchy h
LEFT JOIN position pos ON h.portfolio_node_id = pos.portfolio_node_id
LEFT JOIN valuation_result vr ON pos.position_id = vr.position_id
  AND (%(rid)s IS NULL OR vr.run_id = %(rid)s)
  AND vr.scenario_id = 'BASE'
GROUP BY h.portfolio_node_id, h.name, h.parent_id, h.node_type, h.depth, h.tree_path
ORDER BY h.tree_path;
```

Use db_conn() context manager for all queries. Handle exceptions with try/except, raise HTTPException(500) on database errors.
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Test create root portfolio
curl -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Fund", "node_type": "FUND"}' | jq .

# Test create child portfolio
PARENT_ID=$(curl -s http://localhost:8004/api/v1/portfolios | jq -r '.[0].portfolio_node_id')
curl -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d "{\"name\": \"Test Desk\", \"node_type\": \"DESK\", \"parent_id\": \"$PARENT_ID\"}" | jq .

# Test hierarchy tree
curl -s http://localhost:8004/api/v1/portfolios/$PARENT_ID/tree | jq .

# Clean up
pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Portfolio CRUD endpoints working. Hierarchy tree query returns nested structure with position counts. Direct children query works. Reparent prevents cycles. All endpoints return proper HTTP status codes and error messages. PV aggregation documented to require Phase 2 valuation data.</done>
</task>

<task type="auto">
  <name>Task 3: Implement position CRUD and tagging</name>
  <files>
services/portfolio_svc/app/routes/positions.py
services/portfolio_svc/app/routes/tags.py
  </files>
  <action>
Replace stub implementations in positions.py and tags.py with working endpoints for position management and tagging.

**positions.py endpoints:**

1. `POST /api/v1/positions` - Create position
   - Accept PositionCreate (portfolio_node_id, instrument_id, quantity, base_ccy, cost_basis, book_value, tags_json)
   - Validate portfolio_node_id exists: SELECT 1 FROM portfolio_node WHERE portfolio_node_id = %(pid)s
   - Validate instrument_id exists: SELECT 1 FROM instrument WHERE instrument_id = %(iid)s
   - If either missing, raise 404 with descriptive message
   - Generate position_id = f"pos-{uuid4()}"
   - INSERT INTO position with status='ACTIVE', created_at=now()
   - Return PositionOut with created position

2. `GET /api/v1/positions` - List positions with filtering
   - Accept query params: portfolio_node_id, instrument_id, status, limit, offset
   - Build WHERE clause dynamically based on provided filters
   - SELECT * FROM position WHERE <filters> ORDER BY created_at DESC LIMIT %(lim)s OFFSET %(off)s
   - Return List[PositionOut]

3. `GET /api/v1/positions/{position_id}` - Get single position
   - SELECT * FROM position WHERE position_id = %(pid)s
   - Raise 404 if not found
   - Return PositionOut

4. `PATCH /api/v1/positions/{position_id}` - Update position
   - Accept PositionUpdate (quantity, cost_basis, book_value, tags_json, status - all optional)
   - UPDATE position SET ..., updated_at=now() WHERE position_id = %(pid)s
   - Return updated PositionOut

5. `DELETE /api/v1/positions/{position_id}` - Soft delete position
   - UPDATE position SET status='DELETED', updated_at=now() WHERE position_id = %(pid)s
   - Return 204 No Content

6. `GET /api/v1/positions/{position_id}/valuation` - Get latest valuation for position
   - SELECT * FROM valuation_result WHERE position_id = %(pid)s ORDER BY run_id DESC LIMIT 1
   - Join to run table for as_of_time
   - Return valuation with measures_json

7. `GET /api/v1/positions/by-portfolio/{portfolio_node_id}` - List positions for portfolio
   - SELECT * FROM position WHERE portfolio_node_id = %(pid)s AND status='ACTIVE'
   - Join to instrument table for instrument details
   - Return List[PositionOut] with instrument metadata

**tags.py endpoints:**

1. `POST /api/v1/tags/portfolio/{portfolio_id}` - Add tags to portfolio
   - Accept TagUpdate (tags: List[str])
   - Merge new tags with existing tags_json in portfolio_node
   - UPDATE portfolio_node SET tags_json = tags_json || %(new_tags)s::jsonb WHERE portfolio_node_id = %(pid)s
   - Return updated portfolio with merged tags

2. `DELETE /api/v1/tags/portfolio/{portfolio_id}` - Remove tags from portfolio
   - Accept TagUpdate (tags: List[str])
   - Remove specified tags from tags_json
   - UPDATE portfolio_node SET tags_json = tags_json - %(tags_to_remove)s WHERE portfolio_node_id = %(pid)s
   - Return updated portfolio

3. `GET /api/v1/tags/portfolio` - List all portfolios with specific tag
   - Accept query param: tag (required)
   - SELECT * FROM portfolio_node WHERE tags_json ? %(tag)s
   - Return List[PortfolioOut]

4. `POST /api/v1/tags/position/{position_id}` - Add tags to position
   - Same pattern as portfolio tagging
   - UPDATE position table

5. `DELETE /api/v1/tags/position/{position_id}` - Remove tags from position
   - Same pattern as portfolio tag removal

6. `GET /api/v1/tags/position` - List all positions with specific tag
   - SELECT * FROM position WHERE tags_json ? %(tag)s AND status='ACTIVE'

7. `GET /api/v1/tags/all` - List all unique tags across portfolios and positions
   - SELECT DISTINCT jsonb_object_keys(tags_json) AS tag FROM portfolio_node
   - UNION with position table
   - Return List[str] of unique tags

Use db_conn() for all queries. Validate foreign keys before INSERT to provide helpful error messages. Handle constraint violations gracefully. Use PostgreSQL JSONB operators for tag operations.
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create test instrument
INSTR_ID=$(curl -s -X POST http://localhost:8004/api/v1/instruments \
  -H "Content-Type: application/json" \
  -d '{"instrument_type": "LOAN", "terms_json": {"notional": 1000000}}' | jq -r '.instrument_id')

# Create test portfolio
PORT_ID=$(curl -s -X POST http://localhost:8004/api/v1/portfolios \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Portfolio", "node_type": "BOOK"}' | jq -r '.portfolio_node_id')

# Create position
curl -X POST http://localhost:8004/api/v1/positions \
  -H "Content-Type: application/json" \
  -d "{\"portfolio_node_id\": \"$PORT_ID\", \"instrument_id\": \"$INSTR_ID\", \"quantity\": 1000000, \"base_ccy\": \"USD\", \"cost_basis\": 1000000, \"book_value\": 1000000}" | jq .

# Add tags to portfolio
curl -X POST http://localhost:8004/api/v1/tags/portfolio/$PORT_ID \
  -H "Content-Type: application/json" \
  -d '{"tags": ["high-yield", "energy-sector"]}' | jq .

# List all tags
curl -s http://localhost:8004/api/v1/tags/all | jq .

pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Position CRUD endpoints working. Foreign key validation provides helpful errors. Positions link correctly to portfolios and instruments. Soft delete preserves data. Tagging endpoints working for both portfolios and positions. JSONB operations handle NULL values. Tag queries filter correctly.</done>
</task>

</tasks>

<verification>
**Instrument Master (PORT-01):**
- [ ] Create instruments with type and terms_json
- [ ] List/query instruments by type, tags, search
- [ ] Update instruments (creates new version)
- [ ] Delete/retire instruments with validation (no active positions)
- [ ] Bulk create instruments
- [ ] Version history queryable
- [ ] Basic versioning (APPROVED/RETIRED status) - DATA-03 scope clarified

**Portfolio Management:**
- [ ] Create portfolio nodes with parent-child relationships
- [ ] List root portfolios and direct children
- [ ] Update portfolio metadata (name, tags, metadata_json)
- [ ] Delete portfolios with validation (no children, no positions)
- [ ] Reparent prevents cycles in hierarchy

**Hierarchy Queries:**
- [ ] Recursive CTE returns full tree structure
- [ ] Position counts aggregate correctly per node
- [ ] PV sums work when run_id provided (requires Phase 2 data)
- [ ] Tree depth limited to prevent runaway recursion
- [ ] Nested tree structure built correctly in Python

**Position Management:**
- [ ] Create positions linked to portfolios and instruments
- [ ] Foreign key validation provides helpful errors
- [ ] List positions with filtering by portfolio, instrument, status
- [ ] Update position quantities and metadata
- [ ] Soft delete preserves position data
- [ ] Latest valuation queryable per position

**Tagging:**
- [ ] Add/remove tags for portfolios and positions
- [ ] JSONB operations handle NULL values
- [ ] Query entities by tag
- [ ] List all unique tags across both tables
</verification>

<success_criteria>
**Portfolio hierarchy, instrument master, and position management complete when:**
- User can create/update/delete instruments via API (PORT-01)
- Instrument versions tracked with APPROVED/RETIRED status (DATA-03 basic scope)
- User can create multi-level hierarchy (fund → desk → book) via API
- Hierarchy tree query returns nested structure with metrics in <1 second
- Positions link to instruments with foreign key validation
- Position CRUD operations work with filtering and pagination
- Tags enable portfolio segmentation and filtering
- All endpoints return proper HTTP status codes and error messages
- PV aggregations work when Phase 2 valuation data available (dependency documented)
</success_criteria>

<output>
After completion, create `.planning/phases/03-portfolio-data-services/03-02-SUMMARY.md` documenting:
- Instrument master CRUD implementation (PORT-01)
- Basic versioning approach (DATA-03 scope)
- Endpoints implemented with example curl commands
- Recursive CTE performance characteristics
- Foreign key validation strategy
- Tag query patterns
- Phase 2 dependency for PV aggregations
</output>
