---
phase: 03-portfolio-data-services
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - services/portfolio_svc/app/routes/aggregation.py
  - services/portfolio_svc/app/models.py
  - services/common/portfolio_queries.py
autonomous: true

must_haves:
  truths:
    - "User can query portfolio metrics grouped by issuer with concentration percentages"
    - "User can aggregate positions by sector, rating, geography, currency, product type"
    - "Reference data lookups work for all positions (issuer, sector, geography, rating)"
    - "Aggregations handle NULL reference data gracefully (show 'Unknown' bucket)"
    - "Multi-currency positions convert to base currency USD using FX spots"
  artifacts:
    - path: "services/portfolio_svc/app/routes/aggregation.py"
      provides: "Portfolio aggregation endpoints by dimension"
      exports: ["aggregate_by_issuer", "aggregate_by_sector", "aggregate_by_rating"]
    - path: "services/common/portfolio_queries.py"
      provides: "SQL builders for aggregation with FX conversion"
      exports: ["build_issuer_aggregation_query", "build_sector_aggregation_query"]
  key_links:
    - from: "services/portfolio_svc/app/routes/aggregation.py"
      to: "reference_data table"
      via: "JOIN on instrument.issuer_id"
      pattern: "LEFT JOIN reference_data"
    - from: "aggregation queries"
      to: "fx_spot table"
      via: "Currency conversion CASE WHEN base_ccy = 'USD'"
      pattern: "COALESCE(fx.spot_rate, 1.0)"
---

<objective>
Implement portfolio aggregation queries by issuer, sector, rating, geography, currency, and product type. Enable reference data lookups and multi-currency conversion for comprehensive portfolio analytics.

Purpose: Query layer for portfolio drill-down and exposure analysis; supports regulatory reporting and risk management.
Output: Working aggregation service with dimension-based queries and reference data integration.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-portfolio-data-services/03-RESEARCH.md
@.planning/phases/03-portfolio-data-services/03-01-SUMMARY.md

# Database schema
@sql/002_portfolio_data_services.sql

# Service scaffolding
@services/portfolio_svc/app/routes/aggregation.py
@services/portfolio_svc/app/models.py

# Shared utilities
@services/common/db.py
@services/common/portfolio_queries.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement reference data management endpoints</name>
  <files>
services/portfolio_svc/app/routes/reference_data.py
services/portfolio_svc/app/main.py
  </files>
  <action>
Create new reference_data.py route module for reference data CRUD (issuers, sectors, ratings).

**reference_data.py endpoints:**

1. `POST /api/v1/reference-data` - Create reference data entity
   - Accept ReferenceDataCreate (entity_type, name, ticker, cusip, isin, sector, geography, currency, parent_entity_id, metadata_json)
   - Validate entity_type IN ('ISSUER', 'SECTOR', 'GEOGRAPHY', 'CURRENCY')
   - Generate entity_id = f"{entity_type.lower()}-{uuid4()}"
   - INSERT INTO reference_data
   - Return ReferenceDataOut

2. `GET /api/v1/reference-data` - List reference data with filtering
   - Accept query params: entity_type, sector, geography, search (name/ticker/cusip)
   - Build WHERE clause dynamically
   - Support text search: WHERE name ILIKE %(search)s OR ticker ILIKE %(search)s
   - Return List[ReferenceDataOut]

3. `GET /api/v1/reference-data/{entity_id}` - Get single entity
   - Return ReferenceDataOut or 404

4. `PATCH /api/v1/reference-data/{entity_id}` - Update entity
   - Accept ReferenceDataUpdate (all fields optional)
   - UPDATE reference_data SET ..., updated_at=now()

5. `POST /api/v1/reference-data/{entity_id}/rating` - Add rating history entry
   - Accept RatingHistoryCreate (agency, rating, outlook, as_of_date, effective_date)
   - Generate rating_id = f"rating-{uuid4()}"
   - INSERT INTO rating_history
   - Return RatingHistoryOut

6. `GET /api/v1/reference-data/{entity_id}/ratings` - Get rating history
   - SELECT * FROM rating_history WHERE entity_id = %(eid)s ORDER BY as_of_date DESC
   - Return List[RatingHistoryOut]

7. `GET /api/v1/reference-data/{entity_id}/current-rating` - Get latest rating per agency
   - SELECT DISTINCT ON (agency) * FROM rating_history WHERE entity_id = %(eid)s ORDER BY agency, as_of_date DESC
   - Return Dict[agency, RatingHistoryOut]

Add router to main.py:
```python
from services.portfolio_svc.app.routes.reference_data import router as reference_data_router
app.include_router(reference_data_router, prefix="/api/v1/reference-data", tags=["reference-data"])
```

Use db_conn() for all queries. Handle constraint violations (duplicate ticker/cusip).
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create issuer
curl -X POST http://localhost:8004/api/v1/reference-data \
  -H "Content-Type: application/json" \
  -d '{"entity_type": "ISSUER", "name": "Goldman Sachs", "ticker": "GS", "sector": "Financials", "geography": "US", "currency": "USD"}' | jq .

# Add rating
ENTITY_ID=$(curl -s http://localhost:8004/api/v1/reference-data?entity_type=ISSUER | jq -r '.[0].entity_id')
curl -X POST http://localhost:8004/api/v1/reference-data/$ENTITY_ID/rating \
  -H "Content-Type: application/json" \
  -d '{"agency": "SP", "rating": "A", "outlook": "STABLE", "as_of_date": "2026-02-11", "effective_date": "2026-02-11"}' | jq .

# Get current ratings
curl -s http://localhost:8004/api/v1/reference-data/$ENTITY_ID/current-rating | jq .

pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Reference data CRUD working. Rating history tracking functional. Text search by name/ticker/cusip. Current rating query returns latest per agency.</done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-dimensional aggregation queries</name>
  <files>
services/portfolio_svc/app/routes/aggregation.py
services/common/portfolio_queries.py
  </files>
  <action>
Replace stub implementations in aggregation.py with working aggregation endpoints. Create SQL query builders in portfolio_queries.py.

**aggregation.py endpoints (all accept portfolio_id, optional run_id):**

1. `GET /api/v1/aggregation/{portfolio_id}/by-issuer` - Aggregate by issuer
   - Call build_issuer_aggregation_query(portfolio_id, run_id)
   - Return rows with: issuer_id, issuer_name, pv_usd, position_count, weight_pct
   - ORDER BY pv_usd DESC

2. `GET /api/v1/aggregation/{portfolio_id}/by-sector` - Aggregate by sector
   - Call build_sector_aggregation_query(portfolio_id, run_id)
   - Return rows with: sector, pv_usd, position_count, weight_pct

3. `GET /api/v1/aggregation/{portfolio_id}/by-rating` - Aggregate by credit rating
   - Join to rating_history for latest rating
   - GROUP BY rating
   - Return rows with: rating, agency, pv_usd, position_count, weight_pct

4. `GET /api/v1/aggregation/{portfolio_id}/by-geography` - Aggregate by geography
   - Join to reference_data for geography
   - GROUP BY geography

5. `GET /api/v1/aggregation/{portfolio_id}/by-currency` - Aggregate by currency
   - GROUP BY position.base_ccy
   - Return both local currency totals and USD-converted totals
   - Show FX exposure per currency pair

6. `GET /api/v1/aggregation/{portfolio_id}/by-product-type` - Aggregate by product type
   - Join to instrument for instrument_type
   - GROUP BY instrument_type

**portfolio_queries.py SQL builders:**

Create build_issuer_aggregation_query(portfolio_id, run_id=None, snapshot_id=None):
```sql
WITH position_pv AS (
  SELECT
    ref.entity_id AS issuer_id,
    ref.name AS issuer_name,
    pos.base_ccy,
    (vr.measures_json ->> 'PV')::numeric AS pv_local,
    CASE
      WHEN pos.base_ccy = 'USD' THEN (vr.measures_json ->> 'PV')::numeric
      ELSE (vr.measures_json ->> 'PV')::numeric * COALESCE(fx.spot_rate, 1.0)
    END AS pv_usd
  FROM position pos
  LEFT JOIN instrument instr ON pos.instrument_id = instr.instrument_id
  LEFT JOIN instrument_version iv ON instr.instrument_id = iv.instrument_id AND iv.status = 'APPROVED'
  LEFT JOIN reference_data ref ON (iv.terms_json ->> 'issuer_id') = ref.entity_id
  LEFT JOIN valuation_result vr ON pos.position_id = vr.position_id
    AND (%(rid)s IS NULL OR vr.run_id = %(rid)s)
    AND vr.scenario_id = 'BASE'
  LEFT JOIN fx_spot fx ON fx.pair = pos.base_ccy || '/USD'
    AND (%(sid)s IS NULL OR fx.snapshot_id = %(sid)s)
  WHERE pos.portfolio_node_id = %(port_id)s AND pos.status = 'ACTIVE'
)
SELECT
  COALESCE(issuer_id, 'UNKNOWN') AS issuer_id,
  COALESCE(issuer_name, 'Unknown Issuer') AS issuer_name,
  COALESCE(SUM(pv_usd), 0) AS pv_usd,
  COUNT(DISTINCT base_ccy) AS ccy_count,
  ROUND(100.0 * SUM(pv_usd) / NULLIF(SUM(SUM(pv_usd)) OVER (), 0), 2) AS weight_pct
FROM position_pv
GROUP BY issuer_id, issuer_name
HAVING SUM(pv_usd) IS NOT NULL
ORDER BY pv_usd DESC;
```

Replicate pattern for sector, rating, geography queries. Handle NULL reference data with COALESCE to 'Unknown' bucket. Use window function `SUM(SUM(pv_usd)) OVER ()` for weight_pct calculation.

All aggregation endpoints:
- Accept optional run_id (default to latest run if NULL)
- Accept optional snapshot_id for FX conversion (default to run's snapshot)
- Handle positions without valuations (show 0 PV)
- Handle missing reference data (show 'Unknown' bucket)
- Return empty list if portfolio has no positions
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Create test data (portfolio, issuer, position with valuation)
# Assume setup from previous plans

# Test issuer aggregation
PORT_ID="test-portfolio-1"
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/by-issuer" | jq .

# Test sector aggregation
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/by-sector" | jq .

# Test currency aggregation
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/by-currency" | jq .

# Verify weight percentages sum to 100%
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/by-issuer" | jq '[.[].weight_pct] | add'

pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>All aggregation dimensions working. Multi-currency conversion uses FX spots correctly. Weight percentages sum to 100%. NULL reference data shows as 'Unknown' bucket. Empty portfolios return empty arrays.</done>
</task>

<task type="auto">
  <name>Task 3: Implement portfolio metrics calculation</name>
  <files>services/portfolio_svc/app/routes/aggregation.py</files>
  <action>
Add portfolio-level metrics endpoint returning all PORT-08 requirements: Market value, Book value, Accrued interest, Unrealized/Realized P&L, Portfolio yield, WAM (Weighted Average Maturity), WAL (Weighted Average Life).

**New endpoint:**

`GET /api/v1/aggregation/{portfolio_id}/metrics` - Calculate portfolio-level metrics

Accept optional run_id, return:
```json
{
  "portfolio_node_id": "port-123",
  "run_id": "run-456",
  "as_of_date": "2026-02-11T00:00:00Z",
  "metrics": {
    "market_value_usd": 1000000000.0,
    "book_value_usd": 980000000.0,
    "accrued_interest_usd": 5000000.0,
    "unrealized_pnl_usd": 20000000.0,
    "realized_pnl_usd": 0.0,
    "portfolio_yield_pct": 4.25,
    "weighted_average_maturity_years": 5.3,
    "weighted_average_life_years": 4.8,
    "position_count": 1500,
    "instrument_count": 1200
  },
  "currency_breakdown": [
    {"ccy": "USD", "market_value": 850000000.0, "weight_pct": 85.0},
    {"ccy": "EUR", "market_value": 150000000.0, "weight_pct": 15.0}
  ]
}
```

**Calculation logic:**

- **market_value_usd**: SUM(PV converted to USD) from valuation_result
- **book_value_usd**: SUM(position.book_value converted to USD)
- **accrued_interest_usd**: SUM(ACCRUED_INTEREST measure from valuation_result)
- **unrealized_pnl_usd**: market_value_usd - book_value_usd
- **realized_pnl_usd**: Track separately in position.realized_pnl_json if available, else 0
- **portfolio_yield_pct**: Weighted average of YTM measure: SUM(YTM × PV) / SUM(PV)
- **weighted_average_maturity_years**: SUM(maturity_years × PV) / SUM(PV) from instrument metadata
- **weighted_average_life_years**: SUM(WAL measure × PV) / SUM(PV) if available
- **position_count**: COUNT(DISTINCT position_id)
- **instrument_count**: COUNT(DISTINCT instrument_id)

Query should:
- Join position → instrument → instrument_version for maturity metadata
- Join position → valuation_result for PV, ACCRUED_INTEREST, YTM measures
- Apply FX conversion for all non-USD positions
- Handle NULL measures gracefully (skip in weighted averages)
- Return 0 values if portfolio has no positions/valuations

Use single CTE to compute all metrics in one query for efficiency.
  </action>
  <verify>
```bash
# Start portfolio service
uvicorn services.portfolio_svc.app.main:app --reload --port 8004 &
sleep 3

# Test metrics endpoint
PORT_ID="test-portfolio-1"
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/metrics" | jq .

# Verify all fields present
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/metrics" | jq '.metrics | keys'

# Check currency breakdown
curl -s "http://localhost:8004/api/v1/aggregation/$PORT_ID/metrics" | jq '.currency_breakdown'

pkill -f "uvicorn.*portfolio_svc"
```
  </verify>
  <done>Portfolio metrics endpoint returns all required metrics. Weighted averages calculated correctly. Multi-currency breakdown shows distribution. Empty portfolios return 0 values without errors.</done>
</task>

</tasks>

<verification>
**Reference Data:**
- [ ] Create/update issuers, sectors, geographies
- [ ] Rating history tracking with temporal queries
- [ ] Text search by name/ticker/cusip
- [ ] Current rating per agency query

**Aggregation Queries:**
- [ ] Issuer aggregation with concentration percentages
- [ ] Sector, rating, geography, currency, product type aggregations
- [ ] Multi-currency conversion using FX spots
- [ ] NULL reference data shows as 'Unknown' bucket
- [ ] Weight percentages sum to 100%
- [ ] Empty portfolios return empty arrays

**Portfolio Metrics:**
- [ ] Market value, book value, accrued interest calculated
- [ ] Unrealized P&L = market value - book value
- [ ] Portfolio yield = weighted average YTM
- [ ] WAM and WAL computed from instrument metadata
- [ ] Currency breakdown shows distribution
- [ ] All metrics handle NULL values gracefully
</verification>

<success_criteria>
**Reference data and aggregation complete when:**
- User can create/query reference data (issuers, sectors, ratings)
- All aggregation dimensions return results with concentration percentages
- Multi-currency positions aggregate correctly in USD
- Portfolio metrics calculate all PORT-08 requirements
- Queries return in <1 second for 10K positions
- NULL reference data handled gracefully (Unknown bucket)
</success_criteria>

<output>
After completion, create `.planning/phases/03-portfolio-data-services/03-03-SUMMARY.md` documenting:
- Aggregation query patterns and performance
- Multi-currency conversion strategy
- Portfolio metrics calculation formulas
- Reference data schema and indexing
</output>
