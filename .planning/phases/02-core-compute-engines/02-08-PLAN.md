---
phase: 02-core-compute-engines
plan: 08
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03", "02-07"]
files_modified:
  - compute/risk/credit/pd_model.py
  - compute/risk/credit/expected_loss.py
  - compute/risk/liquidity/metrics.py
  - compute/risk/market/var.py
  - compute/risk/market/expected_shortfall.py
  - services/common/scenario_service.py
  - compute/quantlib/monte_carlo.py
  - compute/tests/test_credit_risk.py
  - compute/tests/test_var.py
autonomous: true

must_haves:
  truths:
    - "PD model constructs probability of default curve from ratings"
    - "Expected loss calculated as PD × LGD × EAD"
    - "VaR computed via historical and parametric methods"
    - "Expected Shortfall measures tail risk beyond VaR"
    - "Liquidity metrics track bid/ask spreads and time-to-liquidate"
    - "Monte Carlo engine generates interest rate paths"
    - "Scenario service provides CRUD for scenario definitions"
  artifacts:
    - path: "compute/risk/credit/pd_model.py"
      provides: "PD curve construction from ratings"
      exports: ["build_pd_curve"]
      min_lines: 50
    - path: "compute/risk/credit/expected_loss.py"
      provides: "Expected loss calculation"
      exports: ["calculate_expected_loss"]
      min_lines: 40
    - path: "compute/risk/market/var.py"
      provides: "VaR calculations (Historical, Parametric)"
      exports: ["calculate_var_historical", "calculate_var_parametric"]
      min_lines: 60
    - path: "compute/risk/market/expected_shortfall.py"
      provides: "Expected Shortfall (CVaR)"
      exports: ["calculate_expected_shortfall"]
      min_lines: 40
    - path: "compute/quantlib/monte_carlo.py"
      provides: "Monte Carlo path generation"
      exports: ["generate_rate_paths"]
      min_lines: 70
    - path: "services/common/scenario_service.py"
      provides: "Scenario CRUD service"
      exports: ["ScenarioService"]
      min_lines: 100
  key_links:
    - from: "compute/risk/credit/expected_loss.py"
      to: "PD × LGD × EAD"
      via: "formula"
      pattern: "pd.*lgd.*ead"
    - from: "compute/risk/market/var.py"
      to: "portfolio returns distribution"
      via: "quantile calculation"
      pattern: "np\\.percentile"
    - from: "compute/quantlib/monte_carlo.py"
      to: "QuantLib.HullWhite"
      via: "path generator"
      pattern: "GaussianPathGenerator"
---

<objective>
Implement credit risk analytics (RISK-05), liquidity risk (RISK-07), VaR/ES (RISK-04), Monte Carlo simulation (SCEN-03), and scenario management service (SCEN-01, SCEN-02, SCEN-04). Completes Phase 2 risk and scenario infrastructure.

Purpose: Covers remaining risk requirements and scenario infrastructure. VaR/ES are regulatory requirements. Credit risk is core to fixed income. Monte Carlo enables scenario forecasting. Scenario service provides CRUD for stress testing.

Output: Complete risk analytics suite and scenario infrastructure, enabling end-to-end scenario execution.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/risk/market/duration.py
@compute/cashflow/default_model.py
@compute/quantlib/curve_builder.py
@services/run_orchestrator/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement credit risk analytics (PD model, expected loss)</name>
  <files>compute/risk/credit/pd_model.py, compute/risk/credit/expected_loss.py</files>
  <action>
**pd_model.py implementation:**

**build_pd_curve(rating: str, time_horizon_years: int = 10) -> List[float]:**
- Map rating to cumulative default probability curve
- Use industry-standard PD curves (Moody's/S&P historical data):
  - AAA: [0.0001, 0.0002, 0.0003, ...] (very low)
  - BBB: [0.0020, 0.0045, 0.0075, ...] (investment grade)
  - B: [0.0500, 0.1000, 0.1500, ...] (high yield)
- Return list of marginal PD per year (not cumulative)
- Convert cumulative to marginal: marginal[t] = cumulative[t] - cumulative[t-1]
- Extrapolate beyond table using constant hazard rate
- Support ratings: AAA, AA, A, BBB, BB, B, CCC

**Simplification per research open question 5:** Use lookup table of historical PDs. Document that econometric PD models (Merton, CreditMetrics) are future enhancement.

**expected_loss.py implementation:**

**calculate_expected_loss(pd: float, lgd: float, ead: float) -> float:**
- Formula: EL = PD × LGD × EAD
- PD: Probability of default (decimal, e.g., 0.02 = 2%)
- LGD: Loss given default (decimal, e.g., 0.40 = 40% loss)
- EAD: Exposure at default (dollar amount)
- Return expected loss in dollars

**calculate_unexpected_loss(pd: float, lgd: float, ead: float) -> float:**
- Formula: UL = EAD × LGD × sqrt(PD × (1 - PD))
- Measures volatility of credit loss distribution
- Used for economic capital calculation

Validate: 0 ≤ PD ≤ 1, 0 ≤ LGD ≤ 1, EAD ≥ 0
  </action>
  <verify>
Run: `python -c "from compute.risk.credit.pd_model import build_pd_curve; from compute.risk.credit.expected_loss import calculate_expected_loss; pd_curve = build_pd_curve('BBB', 5); print(f'Year 1 PD: {pd_curve[0]:.4f}'); el = calculate_expected_loss(0.02, 0.40, 100000); print(f'Expected loss: ${el:.2f}'); assert 700 < el < 900"`

Expected: BBB Year 1 PD ~0.20%. EL = $800 (2% × 40% × $100K). No exceptions.
  </verify>
  <done>PD curve construction from ratings implemented. Expected and unexpected loss formulas correct. Rating lookup table established.</done>
</task>

<task type="auto">
  <name>Task 2: Implement VaR and Expected Shortfall</name>
  <files>compute/risk/market/var.py, compute/risk/market/expected_shortfall.py</files>
  <action>
**var.py implementation:**

**calculate_var_historical(returns: List[float], confidence_level: float = 0.95) -> float:**
- Historical VaR from empirical return distribution
- Sort returns ascending
- Find percentile: VaR = -returns[int((1 - confidence_level) * len(returns))]
- Negative sign convention: VaR is positive for losses
- Return VaR as positive number (loss magnitude)
- Support confidence levels: 0.90, 0.95, 0.99

**calculate_var_parametric(mean: float, std_dev: float, confidence_level: float = 0.95) -> float:**
- Parametric VaR assuming normal distribution
- Formula: VaR = -(mean + z_score * std_dev)
- z_score for 95% = -1.645, for 99% = -2.326
- Use SciPy stats.norm.ppf() for z-score lookup
- Return VaR as positive loss magnitude

**Validation:** Handle empty returns list, zero std_dev, confidence out of range [0, 1].

**expected_shortfall.py implementation:**

**calculate_expected_shortfall(returns: List[float], confidence_level: float = 0.95) -> float:**
- ES (CVaR) = mean of returns beyond VaR threshold
- Sort returns ascending
- Identify VaR cutoff
- Calculate mean of worst (1 - confidence_level)% returns
- Return ES as positive number
- ES ≥ VaR (always true for coherent risk measure)

Per research "State of the Art", ES is required for Basel III regulatory capital. Implement alongside VaR.
  </action>
  <verify>
Run: `python -c "import numpy as np; from compute.risk.market.var import calculate_var_historical, calculate_var_parametric; from compute.risk.market.expected_shortfall import calculate_expected_shortfall; returns = np.random.normal(-0.0005, 0.02, 1000).tolist(); var = calculate_var_historical(returns, 0.95); es = calculate_expected_shortfall(returns, 0.95); print(f'VaR 95%: {var:.4f}, ES 95%: {es:.4f}'); assert es >= var"`

Expected: VaR ~0.033 (1.645 std devs), ES > VaR. No exceptions.
  </verify>
  <done>Historical and parametric VaR implemented. Expected Shortfall calculated from tail distribution. ES ≥ VaR validation passes.</done>
</task>

<task type="auto">
  <name>Task 3: Implement Monte Carlo path generation and liquidity metrics</name>
  <files>compute/quantlib/monte_carlo.py, compute/risk/liquidity/metrics.py</files>
  <action>
**monte_carlo.py implementation:**

**generate_rate_paths(model: str, num_paths: int, time_horizon_years: int, time_steps: int, model_params: Dict) -> np.ndarray:**
- Generate interest rate paths using QuantLib stochastic models
- Support models: 'HULL_WHITE', 'VASICEK', 'CIR'
- For Hull-White (default):
  - Create ql.HullWhite(curve_handle, a=model_params['a'], sigma=model_params['sigma'])
  - Use GaussianPathGenerator with UniformRandomSequenceGenerator
  - Extract paths as NumPy array (shape: num_paths × time_steps)
- For Vasicek/CIR: Use respective QuantLib models
- Return paths: array[path_id, time_step] = interest_rate
- Paths used for scenario analysis and VaR calculation

Follow research "Pattern 5: Monte Carlo Path Generation". Use low-discrepancy sequences (Sobol) for variance reduction if num_paths > 1000.

**liquidity/metrics.py implementation:**

**calculate_bid_ask_spread(bid_price: float, ask_price: float) -> float:**
- Spread = (ask_price - bid_price) / mid_price
- mid_price = (bid + ask) / 2
- Return as decimal (e.g., 0.005 = 50 bps)

**estimate_time_to_liquidate(position_size: float, avg_daily_volume: float, participation_rate: float = 0.10) -> float:**
- Time to liquidate = position_size / (avg_daily_volume * participation_rate)
- Return in days
- Assumes constant volume (simplification)

**calculate_lcr(liquid_assets: float, net_cash_outflows_30d: float) -> float:**
- Liquidity Coverage Ratio = liquid_assets / net_cash_outflows_30d
- Basel III requirement: LCR ≥ 100%
- Return ratio (e.g., 1.20 = 120%)

Per requirement RISK-07, these are core liquidity risk metrics.
  </action>
  <verify>
Run: `python -c "from compute.quantlib.monte_carlo import generate_rate_paths; import numpy as np; paths = generate_rate_paths('HULL_WHITE', 10, 5, 60, {'a': 0.03, 'sigma': 0.12}); print(f'Paths shape: {paths.shape}'); assert paths.shape == (10, 61)"`

Expected: 10 paths × 61 time points (0 to 60). Interest rates positive. No exceptions.
  </verify>
  <done>Monte Carlo path generation implemented using QuantLib Hull-White model. Liquidity metrics (bid/ask spread, time-to-liquidate, LCR) calculated correctly.</done>
</task>

<task type="auto">
  <name>Task 4: Implement scenario management service and add tests</name>
  <files>services/common/scenario_service.py, compute/tests/test_credit_risk.py, compute/tests/test_var.py</files>
  <action>
**scenario_service.py implementation:**

Create FastAPI service class (not full microservice — shared module):

```python
class ScenarioService:
    """Scenario definition and management (SCEN-01, SCEN-02)."""

    def create_scenario(self, scenario_def: Dict) -> str:
        """Create new scenario definition. Returns scenario_id."""
        # Validate scenario structure (type, shocks, name)
        # Store in database (scenario table)
        # Return scenario_id

    def get_scenario(self, scenario_id: str) -> Dict:
        """Retrieve scenario definition."""
        # Load from database
        # Return scenario dict

    def list_scenarios(self, scenario_set: str | None = None) -> List[Dict]:
        """List all scenarios or scenarios in a set (e.g., 'CCAR')."""
        # Query database
        # Return list of scenario dicts

    def create_stress_test(self, shocks: Dict) -> Dict:
        """Create stress test scenario from shock specifications (SCEN-02)."""
        # shocks: {'rates': +100bp, 'spreads': +25bp, 'fx': +1%}
        # Generate scenario definition applying all shocks
        # Return scenario dict

    def run_what_if(self, base_run_id: str, modifications: Dict) -> str:
        """Create what-if scenario by modifying base run (SCEN-04)."""
        # Copy base run
        # Apply modifications (position changes, curve tweaks)
        # Submit new run
        # Return new run_id
```

Use existing database connection pattern from services/common. Store scenarios in `scenario` table (extend schema if needed).

**Create test_credit_risk.py:**
- test_pd_curve_construction(): Validate BBB rating → reasonable PD curve
- test_expected_loss_calculation(): EL = PD × LGD × EAD
- test_unexpected_loss(): UL formula correct

**Create test_var.py:**
- test_var_historical_95(): 95% VaR from sample returns
- test_var_parametric(): Parametric VaR matches normal distribution
- test_expected_shortfall_exceeds_var(): ES ≥ VaR always

Run all tests. Commit: `feat(02-08): implement credit risk, VaR, liquidity, Monte Carlo, and scenario service`
  </action>
  <verify>
Run: `pytest compute/tests/test_credit_risk.py compute/tests/test_var.py -v`. Expected: 6 passes (3 credit, 3 VaR/ES)

Run: `python -c "from services.common.scenario_service import ScenarioService; svc = ScenarioService(); print('ScenarioService initialized')"`
  </verify>
  <done>ScenarioService provides CRUD for scenario definitions. Stress test and what-if scenario creation working. 6 tests pass for credit risk and VaR/ES.</done>
</task>

</tasks>

<verification>
- [ ] PD curves constructed from ratings (AAA to CCC)
- [ ] Expected loss formula (PD × LGD × EAD) correct
- [ ] Historical VaR calculated from return distribution
- [ ] Parametric VaR uses normal distribution assumption
- [ ] Expected Shortfall ≥ VaR (coherent risk measure property)
- [ ] Monte Carlo generates 1000+ paths using QuantLib Hull-White
- [ ] Liquidity metrics (bid/ask, time-to-liquidate, LCR) calculated
- [ ] ScenarioService provides CRUD for scenario definitions
- [ ] Stress test scenarios configurable (rate, spread, FX shocks)
- [ ] 6 tests pass (credit risk, VaR, ES)
</verification>

<success_criteria>
- PD model (RISK-05) constructs default curves from ratings
- Expected loss calculation (RISK-05) implements PD × LGD × EAD formula
- VaR calculations (RISK-04) support historical and parametric methods
- Expected Shortfall (RISK-04) measures tail risk beyond VaR
- Liquidity risk metrics (RISK-07) include bid/ask spread, time-to-liquidate, LCR
- Monte Carlo engine (SCEN-03) generates interest rate paths using QuantLib Hull-White
- Scenario management service (SCEN-01) provides CRUD for scenario definitions
- Stress testing configuration (SCEN-02) supports rate, spread, and FX shocks
- What-if analysis (SCEN-04) enables portfolio rebalancing simulation
- 6 comprehensive tests validate credit risk and VaR/ES calculations
- All Phase 2 risk and scenario requirements complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-08-SUMMARY.md`
</output>
