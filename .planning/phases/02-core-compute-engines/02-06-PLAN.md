---
phase: 02-core-compute-engines
plan: 06
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - compute/cashflow/generator.py
  - compute/cashflow/amortization.py
  - compute/tests/test_cashflow_generator.py
autonomous: true

must_haves:
  truths:
    - "Payment schedules generate from instrument terms and conventions"
    - "Level pay amortization calculates correct principal/interest split"
    - "Bullet payments supported (principal at maturity)"
    - "Custom amortization schedules supported"
  artifacts:
    - path: "compute/cashflow/generator.py"
      provides: "Payment schedule generation engine"
      exports: ["generate_schedule"]
      min_lines: 80
    - path: "compute/cashflow/amortization.py"
      provides: "Amortization logic (level pay, bullet, custom)"
      exports: ["level_pay_schedule", "bullet_schedule", "custom_schedule"]
      min_lines: 70
  key_links:
    - from: "compute/cashflow/generator.py"
      to: "QuantLib.MakeSchedule"
      via: "date schedule generation"
      pattern: "ql\\.MakeSchedule"
    - from: "compute/cashflow/amortization.py"
      to: "level payment formula"
      via: "PMT calculation"
      pattern: "principal.*\\(1 \\+ rate\\)"
---

<objective>
Implement payment schedule generation engine (CF-01) with level pay, bullet, and custom amortization logic. Provides cashflow schedules for all instrument types, consumed by pricers and risk calculators.

Purpose: All cashflow-based analytics (PV, duration, scenario analysis) require accurate payment schedules. This is foundational infrastructure for fixed income analytics.

Output: Cashflow generator and amortization logic with comprehensive tests.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/pricers/bond.py
@compute/pricers/loan.py
@compute/quantlib/day_count.py
@compute/quantlib/calendar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement amortization logic (level pay, bullet, custom)</name>
  <files>compute/cashflow/amortization.py</files>
  <action>
Replace stub with three amortization methods:

**level_pay_schedule(principal: float, annual_rate: float, num_periods: int, frequency: int = 12) -> List[Dict]:**
- Calculate level payment using PMT formula: pmt = principal * (r * (1+r)^n) / ((1+r)^n - 1)
- Where r = annual_rate / frequency, n = num_periods
- For each period:
  - interest_payment = remaining_balance * r
  - principal_payment = pmt - interest_payment
  - remaining_balance -= principal_payment
- Return list of dicts: [{'period': i, 'payment': pmt, 'principal': prin, 'interest': int, 'remaining_balance': bal}]

**bullet_schedule(principal: float, annual_rate: float, num_periods: int, frequency: int = 12) -> List[Dict]:**
- Interest-only payments each period
- Principal paid at maturity (final period)
- For each period except last:
  - interest_payment = principal * (annual_rate / frequency)
  - principal_payment = 0
- Last period:
  - interest_payment = principal * (annual_rate / frequency)
  - principal_payment = principal
- Return schedule

**custom_schedule(cashflow_specs: List[Dict]) -> List[Dict]:**
- Accept explicit cashflow specifications: [{'period': 1, 'principal': 1000, 'interest': 50}, ...]
- Validate: all periods present, principal sums to original balance
- Calculate remaining_balance after each payment
- Return standardized schedule

Use NumPy for vectorized calculations if num_periods > 100. Validate inputs (positive principal, rate > 0, num_periods > 0).
  </action>
  <verify>
Run: `python -c "from compute.cashflow.amortization import level_pay_schedule; sch = level_pay_schedule(100000, 0.05, 360, 12); print(f'Monthly payment: {sch[0][\"payment\"]:.2f}'); print(f'First principal: {sch[0][\"principal\"]:.2f}'); print(f'Final balance: {sch[-1][\"remaining_balance\"]:.2f}'); assert sch[-1]['remaining_balance'] < 0.01"`

Expected: Monthly payment ~$536.82 for $100K at 5% over 30 years. Final balance near zero.
  </verify>
  <done>Level pay, bullet, and custom amortization schedules implemented. PMT formula correct. Balances reconcile to zero.</done>
</task>

<task type="auto">
  <name>Task 2: Implement payment schedule generator with QuantLib</name>
  <files>compute/cashflow/generator.py</files>
  <action>
Replace stub with full schedule generator:

**generate_schedule(instrument: Dict, as_of_date: date, end_date: date | None = None) -> List[Dict]:**

1. Parse instrument definition:
   - issue_date, maturity_date, coupon, frequency, day_count_convention, calendar, amortization_type
2. Create QuantLib Schedule using MakeSchedule:
   - effectiveDate from issue_date or as_of_date
   - terminationDate from maturity_date or end_date
   - tenor (frequency): Monthly, Quarterly, Semiannual, Annual
   - calendar from instrument (default US-GOVT)
   - business day convention (ModifiedFollowing)
   - date generation rule (Backward from maturity)
3. Generate base date schedule from QuantLib
4. Determine amortization method from instrument['amortization_type']:
   - 'LEVEL_PAY' → call level_pay_schedule()
   - 'BULLET' → call bullet_schedule()
   - 'CUSTOM' → call custom_schedule()
   - Default: 'BULLET'
5. Merge QuantLib date schedule with amortization schedule
6. Calculate year fractions using day_count convention
7. Filter for future cashflows only (pay_date > as_of_date)
8. Return list of cashflow dicts with fields:
   - period, pay_date, principal, interest, payment, remaining_balance, year_fraction

**Integration:** Use curve_builder for any forward rate projection if instrument is floating (link to floating_rate pricer logic).

Edge cases: as_of_date between payment dates (partial period accrual), maturity already past (return empty schedule), invalid frequency.
  </action>
  <verify>
Run: `python -c "from compute.cashflow.generator import generate_schedule; from datetime import date; import QuantLib as ql; instr = {'issue_date': '2020-01-01', 'maturity_date': '2030-01-01', 'coupon': 0.05, 'frequency': 'SEMIANNUAL', 'day_count': 'ACT/360', 'calendar': 'US-GOVT', 'amortization_type': 'BULLET', 'principal': 100000}; sch = generate_schedule(instr, date(2026, 2, 11)); print(f'Num future payments: {len(sch)}'); assert len(sch) > 0"`

Expected: 8 future payments (semiannual from 2026 to 2030). No exceptions.
  </verify>
  <done>Payment schedule generator implemented. QuantLib MakeSchedule integrated. Amortization methods applied. Future cashflows filtered correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for cashflow generation</name>
  <files>compute/tests/test_cashflow_generator.py</files>
  <action>
Create test file with 6 test cases:

**test_level_pay_amortization()**
- 30-year mortgage, verify PMT calculation
- Assert first payment is mostly interest, last payment is mostly principal
- Assert remaining balance reaches zero

**test_bullet_amortization()**
- 10-year bullet bond
- Assert all periods have zero principal except last
- Assert interest payments constant

**test_custom_amortization()**
- Custom schedule with irregular principal payments
- Assert schedule matches input specs

**test_schedule_generation_quarterly()**
- Generate quarterly schedule from 2020 to 2030
- Assert 40 payments (10 years × 4 quarters)
- Assert pay_dates respect business day calendar

**test_schedule_with_partial_period()**
- as_of_date is mid-period
- Assert first cashflow is partial (accrued interest handled)

**test_schedule_filtering()**
- as_of_date is 2026, maturity 2030
- Assert only future cashflows returned (pay_date > as_of_date)
- Assert no past payments included

Use pytest fixtures for instrument definitions. Follow existing test patterns.
  </action>
  <verify>Run: `pytest compute/tests/test_cashflow_generator.py -v`</verify>
  <done>6 cashflow generation tests pass. Level pay, bullet, custom amortization validated. Schedule filtering correct.</done>
</task>

</tasks>

<verification>
- [ ] Level pay amortization produces correct PMT and principal/interest split
- [ ] Bullet schedule has zero principal until maturity
- [ ] Custom schedules accept arbitrary cashflow specifications
- [ ] QuantLib MakeSchedule generates correct payment dates
- [ ] Business day calendar adjusts weekend/holiday dates
- [ ] Future-only filtering works correctly
- [ ] 6 tests pass validating all amortization types and edge cases
</verification>

<success_criteria>
- generate_schedule() generates payment schedules from instrument definitions (CF-01)
- QuantLib MakeSchedule integrated for date generation with calendar adjustment
- level_pay_schedule() implements correct PMT formula
- bullet_schedule() generates interest-only with principal at maturity
- custom_schedule() accepts explicit cashflow specifications
- Schedules filter for future cashflows only (pay_date > as_of_date)
- 6 comprehensive tests validate amortization logic and schedule generation
- All pricers can consume generated schedules
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-06-SUMMARY.md`
</output>
