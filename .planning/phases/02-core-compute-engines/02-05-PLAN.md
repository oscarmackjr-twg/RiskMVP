---
phase: 02-core-compute-engines
plan: 05
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - compute/pricers/derivatives.py
  - compute/pricers/structured.py
  - compute/pricers/registry.py
  - compute/cashflow/waterfall.py
  - compute/tests/golden/test_derivatives_golden.py
  - compute/tests/golden/test_structured_golden.py
autonomous: true

must_haves:
  truths:
    - "Interest rate swaps price with multi-curve framework"
    - "Derivatives provide hedge PV and sensitivities"
    - "Structured products apply waterfall logic to cashflows"
    - "Waterfall allocates cashflows across tranches by priority"
  artifacts:
    - path: "compute/pricers/derivatives.py"
      provides: "Derivatives hedge pricer"
      exports: ["price_derivatives"]
      min_lines: 60
    - path: "compute/pricers/structured.py"
      provides: "Structured product pricer"
      exports: ["price_structured"]
      min_lines: 80
    - path: "compute/cashflow/waterfall.py"
      provides: "Waterfall modeling for structured products"
      exports: ["apply_waterfall"]
      min_lines: 60
  key_links:
    - from: "compute/pricers/derivatives.py"
      to: "QuantLib.VanillaSwap"
      via: "swap creation"
      pattern: "VanillaSwap"
    - from: "compute/pricers/structured.py"
      to: "compute.cashflow.waterfall.apply_waterfall"
      via: "tranche allocation"
      pattern: "apply_waterfall"
---

<objective>
Implement derivatives hedge pricer (PRICE-06) for interest rate swaps and structured product pricer (PRICE-05) with waterfall modeling (CF-06). Covers remaining complex instrument types.

Purpose: Derivatives provide hedging for interest rate and FX risk. Structured products (CLOs, CDOs) require waterfall logic to allocate cashflows across tranches. Completes institutional pricer suite.

Output: Two pricers (derivatives, structured) with waterfall logic, registered and tested.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/pricers/fx_fwd.py
@compute/quantlib/curve_builder.py
@compute/cashflow/waterfall.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement derivatives pricer for interest rate swaps</name>
  <files>compute/pricers/derivatives.py</files>
  <action>
Replace stub with interest rate swap pricer:

**Focus:** Interest rate swaps (IRS) for hedging fixed income portfolios. Start simple — vanilla pay-fixed/receive-floating or vice versa.

1. Import QuantLib, curve_builder
2. Implement price_derivatives(position, instrument, market_snapshot, measures, scenario_id):
   - Apply scenario
   - Set evaluation date
   - Build OIS discount curve and SOFR forward curve (multi-curve)
   - Determine swap type from instrument: 'PAY_FIXED' or 'RECEIVE_FIXED'
   - Create QuantLib VanillaSwap:
     - Type: ql.VanillaSwap.Payer or Receiver
     - Notional from position
     - Fixed leg: schedule, fixed_rate, day_count
     - Floating leg: schedule, IborIndex (SOFR 3M), spread
   - Set DiscountingSwapEngine with OIS curve handle
   - Compute measures:
     - 'PV' → swap.NPV()
     - 'DV01' → bump OIS curve +1bp, reprice
     - 'FIXED_LEG_PV' → swap.fixedLegNPV()
     - 'FLOAT_LEG_PV' → swap.floatingLegNPV()
   - Return results

**Simplification per research open question 4:** Start with vanilla IRS. Defer swaptions, caps/floors to future phase. Document in code comment.

**Handle scenarios:** Apply rate shocks to OIS and SOFR curves independently (parallel shifts).
  </action>
  <verify>
Create simple test: `python -c "from compute.pricers.derivatives import price_derivatives; print('Stub replaced')"`

Full validation in Task 3 golden tests.
  </verify>
  <done>Derivatives pricer implemented for vanilla interest rate swaps. Multi-curve framework applied. PV and DV01 computed.</done>
</task>

<task type="auto">
  <name>Task 2: Implement waterfall logic and structured product pricer</name>
  <files>compute/cashflow/waterfall.py, compute/pricers/structured.py</files>
  <action>
**waterfall.py implementation:**

**apply_waterfall(cashflows: List[Dict], tranches: List[Dict]) -> Dict[str, List[Dict]]:**
- tranches: List of dicts with {tranche_id, priority, notional, coupon, subordination}
- Allocate cashflows by priority (senior first, then mezzanine, then equity)
- For each period:
  - Allocate interest: Pay coupons by priority until cash exhausted
  - Allocate principal: Pay down tranches by priority
  - Excess to equity tranche
  - Shortfalls absorbed by most junior tranche
- Return: Dict mapping tranche_id to cashflow schedule
- Add 'shortfall' and 'excess' fields to track allocation

**Simplification per research open question 3:** Generic waterfall logic (not deal-specific). Support simple CLO structure: Senior (AAA), Mezzanine (BBB), Equity. Document that complex deal-specific waterfalls require per-deal customization.

**structured.py implementation:**

**price_structured(position, instrument, market_snapshot, measures, scenario_id):**
- Get collateral pool cashflows (from position or linked positions)
- Get tranche structure from instrument
- Apply waterfall to allocate collateral cashflows to tranches
- For requested tranche (position.tranche_id), discount allocated cashflows
- Compute measures:
  - 'PV' → sum of discounted tranche cashflows
  - 'YIELD' → IRR from tranche cashflows
  - 'COVERAGE_RATIO' → collateral / tranche notional
- Return results

**If collateral cashflows not available:** Use simplified approach (prorate collateral PV by tranche subordination). Document limitation.
  </action>
  <verify>
Run: `python -c "from compute.cashflow.waterfall import apply_waterfall; tranches = [{'tranche_id': 'A', 'priority': 1, 'notional': 80, 'coupon': 0.04}, {'tranche_id': 'B', 'priority': 2, 'notional': 20, 'coupon': 0.08}]; cf = [{'period': 1, 'interest': 5.0, 'principal': 10.0}]; result = apply_waterfall(cf, tranches); print(f'Tranches: {list(result.keys())}'); assert 'A' in result"`

Expected: Returns tranches A and B with allocated cashflows. No exceptions.
  </verify>
  <done>Waterfall logic implemented for tranche allocation. Structured product pricer uses waterfall to price tranches. Coverage ratios computed.</done>
</task>

<task type="auto">
  <name>Task 3: Add golden tests and register pricers</name>
  <files>compute/tests/golden/test_derivatives_golden.py, compute/tests/golden/test_structured_golden.py, compute/pricers/registry.py</files>
  <action>
**Create test_derivatives_golden.py:**

**test_swap_pay_fixed()**
- Pay-fixed 5%, receive SOFR + 0 bps, 5-year maturity, $1M notional
- SOFR curve 4.5%, OIS 4.4%
- Expected: PV positive (paying fixed 5% > receiving floating ~4.5%)
- Assert result['PV'] > 10000

**test_swap_receive_fixed()**
- Receive-fixed 3%, pay SOFR + 0 bps
- SOFR curve 4.5%
- Expected: PV negative (receiving fixed 3% < paying floating ~4.5%)
- Assert result['PV'] < -10000

**Create test_structured_golden.py:**

**test_structured_simple_waterfall()**
- 2-tranche structure: $80M senior (4%), $20M junior (8%)
- Collateral generates $6M annual interest, $10M principal
- Senior gets first $3.2M interest, $8M principal
- Junior gets remaining
- Assert senior_pv > junior_pv (lower risk, lower return)

**test_structured_shortfall()**
- Collateral generates only $2M interest (shortfall)
- Senior gets full $3.2M (paid from junior subordination)
- Junior absorbs shortfall
- Assert junior cashflows reduced

**Update registry.py:**
```python
from compute.pricers.derivatives import price_derivatives
from compute.pricers.structured import price_structured

register("DERIVATIVES", price_derivatives)
register("STRUCTURED", price_structured)
```

Run all tests. Commit: `feat(02-05): implement derivatives and structured product pricers`
  </action>
  <verify>
Run: `pytest compute/tests/golden/test_derivatives_golden.py compute/tests/golden/test_structured_golden.py -v`. Expected: 4 passes (2 derivatives, 2 structured)
Run: `python -c "from compute.pricers.registry import registered_types; print(len(registered_types()))"`. Expected: 9
  </verify>
  <done>4 golden tests pass. Derivatives and structured product pricers registered. Worker can price DERIVATIVES and STRUCTURED product types.</done>
</task>

</tasks>

<verification>
- [ ] Interest rate swaps price using QuantLib VanillaSwap
- [ ] Swap PV separates fixed leg and floating leg values
- [ ] Waterfall allocates cashflows by tranche priority
- [ ] Structured product pricer uses waterfall for tranche valuation
- [ ] 4 golden tests pass (2 derivatives, 2 structured)
- [ ] Both pricers registered in registry
- [ ] Multi-curve framework applied to swaps
</verification>

<success_criteria>
- price_derivatives() prices vanilla interest rate swaps using QuantLib VanillaSwap
- Multi-curve framework separates OIS discount from SOFR projection
- Swap DV01 computed via curve bump-reprice
- apply_waterfall() allocates cashflows across tranches by priority (CF-06)
- price_structured() uses waterfall to value structured product tranches
- Coverage ratios and shortfall handling working
- 4 golden tests validate swap pricing and waterfall logic
- Both pricers registered and functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-05-SUMMARY.md`
</output>
