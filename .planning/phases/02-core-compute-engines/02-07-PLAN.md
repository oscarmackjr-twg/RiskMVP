---
phase: 02-core-compute-engines
plan: 07
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-06"]
files_modified:
  - compute/risk/market/duration.py
  - compute/risk/market/convexity.py
  - compute/risk/market/dv01.py
  - compute/risk/market/key_rate.py
  - compute/risk/market/spread_duration.py
  - compute/tests/test_market_risk.py
autonomous: true

must_haves:
  truths:
    - "Macaulay duration calculated from cashflows and YTM"
    - "Modified duration derived from Macaulay duration"
    - "Effective duration computed via bump-reprice (±50 bps)"
    - "DV01 calculated from 1bp parallel shift"
    - "Key rate durations computed for specific tenors"
    - "Convexity measures price sensitivity to large rate changes"
  artifacts:
    - path: "compute/risk/market/duration.py"
      provides: "Duration calculations (Macaulay, Modified, Effective)"
      exports: ["macaulay_duration", "modified_duration", "effective_duration"]
      min_lines: 50
    - path: "compute/risk/market/dv01.py"
      provides: "DV01 and PV01 calculations"
      exports: ["calculate_dv01", "calculate_pv01"]
      min_lines: 40
    - path: "compute/risk/market/key_rate.py"
      provides: "Key rate duration calculations"
      exports: ["calculate_key_rate_durations"]
      min_lines: 60
    - path: "compute/risk/market/convexity.py"
      provides: "Convexity calculations"
      exports: ["calculate_convexity"]
      min_lines: 40
  key_links:
    - from: "compute/risk/market/duration.py"
      to: "cashflow schedule"
      via: "weighted average life calculation"
      pattern: "sum\\(cf.*time\\)"
    - from: "compute/risk/market/dv01.py"
      to: "pricer bump-reprice"
      via: "scenario application"
      pattern: "apply_scenario.*1BP"
---

<objective>
Implement market risk analytics (RISK-01, RISK-02, RISK-03) including duration (Macaulay, Modified, Effective), DV01/PV01, convexity, key rate durations, and spread duration. Provides comprehensive interest rate risk measurement.

Purpose: Risk-01 through RISK-03 require institutional-grade interest rate risk analytics. These are regulatory requirements (Basel III) and portfolio management essentials. Duration and convexity are core to fixed income risk management.

Output: Complete market risk module with duration, DV01, convexity, and key rate analytics.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/pricers/bond.py
@compute/quantlib/curve_builder.py
@compute/cashflow/generator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement duration calculations (Macaulay, Modified, Effective)</name>
  <files>compute/risk/market/duration.py</files>
  <action>
Replace stub implementations with full duration calculations:

**macaulay_duration(cashflows: List[Dict], ytm: float, frequency: int = 2) -> float:**
- Macaulay duration = weighted average time to cashflow receipt
- Formula: sum(t * PV(CF_t)) / sum(PV(CF_t))
- Where PV(CF_t) = CF_t / (1 + ytm/frequency)^(t*frequency)
- t is time in years from cashflow['year_fraction'] or calculated from pay_date
- Discount each cashflow by YTM
- Weight by present value
- Return weighted average time in years

**modified_duration(macaulay_dur: float, ytm: float, frequency: int = 2) -> float:**
- Already implemented (simple formula)
- Verify formula: ModD = MacD / (1 + ytm/frequency)

**effective_duration(pv_down: float, pv_up: float, pv_base: float, shock_bps: float = 50.0) -> float:**
- Already implemented (bump-reprice formula)
- Verify formula: EffD = (PV_down - PV_up) / (2 * PV_base * shock)
- Default shock 50 bps (0.005) per industry standard

Add helper function:
**calculate_all_durations(cashflows, ytm, pv_base, pv_down, pv_up, frequency=2) -> Dict[str, float]:**
- Returns {'macaulay': X, 'modified': Y, 'effective': Z}
- Single call for all duration types

Use QuantLib BondFunctions.duration() as validation reference for Macaulay duration calculation.
  </action>
  <verify>
Run: `python -c "from compute.risk.market.duration import macaulay_duration, modified_duration, calculate_all_durations; cfs = [{'year_fraction': 0.5, 'payment': 2.5}, {'year_fraction': 1.0, 'payment': 2.5}, {'year_fraction': 1.5, 'payment': 102.5}]; mac = macaulay_duration(cfs, 0.05, 2); mod = modified_duration(mac, 0.05, 2); print(f'Macaulay: {mac:.4f}, Modified: {mod:.4f}'); assert 1.3 < mac < 1.5"`

Expected: Macaulay ~1.45 years for 3-period bond. Modified slightly less. No exceptions.
  </verify>
  <done>Macaulay, Modified, and Effective duration implemented. Weighted average calculation correct. Formulas match financial standards.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DV01, convexity, and spread duration</name>
  <files>compute/risk/market/dv01.py, compute/risk/market/convexity.py, compute/risk/market/spread_duration.py</files>
  <action>
**dv01.py implementation:**

**calculate_dv01(price_base: float, price_up_1bp: float) -> float:**
- DV01 = Price_base - Price_up_1bp
- Measures dollar value of 1 basis point rate increase
- Return absolute change (positive = loss on rate increase)

**calculate_pv01(cashflows: List[Dict], ytm: float, frequency: int = 2) -> float:**
- Alternative calculation from cashflows
- PV01 = sum(t * CF_t / (1 + ytm)^t) / 10000
- Can derive from Modified Duration: PV01 ≈ ModD * PV / 10000
- Return dollar value of 1bp change

**convexity.py implementation:**

**calculate_convexity(pv_base: float, pv_down: float, pv_up: float, shock_bps: float = 50.0) -> float:**
- Convexity = (PV_up + PV_down - 2*PV_base) / (PV_base * shock^2)
- Where shock = shock_bps / 10000
- Measures curvature of price-yield relationship
- Higher convexity = more favorable price behavior for large rate changes

**spread_duration.py implementation:**

**calculate_spread_duration(pv_base: float, pv_spread_up: float, spread_shock_bps: float = 25.0) -> float:**
- Spread duration = (PV_base - PV_spread_up) / (PV_base * spread_shock)
- Measures sensitivity to credit spread changes
- Similar to modified duration but for spread risk
- Use 25 bps shock (industry standard for credit)

All functions validate inputs (non-zero PV_base, positive shocks). Raise ValueError for invalid inputs.
  </action>
  <verify>
Run: `python -c "from compute.risk.market.dv01 import calculate_dv01; from compute.risk.market.convexity import calculate_convexity; dv01 = calculate_dv01(100.0, 99.95); conv = calculate_convexity(100.0, 100.25, 99.75, 50.0); print(f'DV01: {dv01:.4f}, Convexity: {conv:.4f}'); assert 0.04 < dv01 < 0.06"`

Expected: DV01 = 0.05 (5 cents per $100 notional). Convexity positive. No exceptions.
  </verify>
  <done>DV01, PV01, convexity, and spread duration implemented. Formulas match industry standards. Input validation working.</done>
</task>

<task type="auto">
  <name>Task 3: Implement key rate durations</name>
  <files>compute/risk/market/key_rate.py</files>
  <action>
Implement key rate duration calculation:

**calculate_key_rate_durations(base_pv: float, shocked_pvs: Dict[str, float], shock_bps: float = 10.0) -> Dict[str, float]:**
- Key rate duration measures sensitivity to individual points on yield curve
- shocked_pvs: Dict mapping tenor to PV after shocking that tenor {'2Y': pv_2y_up, '5Y': pv_5y_up, '10Y': pv_10y_up}
- For each tenor:
  - key_rate_dur[tenor] = (base_pv - shocked_pvs[tenor]) / (base_pv * shock)
- Return Dict mapping tenor to duration contribution
- Sum of key rate durations ≈ effective duration (validates calculation)

**Tenors to support:** '3M', '6M', '1Y', '2Y', '3Y', '5Y', '7Y', '10Y', '20Y', '30Y'

**Integration with pricers:**
- Pricers must support key rate scenarios (shock individual curve nodes)
- Use QuantLib SpreadedLinearZeroInterpolatedTermStructure to apply tenor-specific shocks
- Document pattern in code comments

**Validation:** Sum of key rate durations should approximately equal effective duration (within 10% tolerance).
  </action>
  <verify>
Run: `python -c "from compute.risk.market.key_rate import calculate_key_rate_durations; shocked = {'2Y': 99.5, '5Y': 99.3, '10Y': 99.0}; krd = calculate_key_rate_durations(100.0, shocked, 10.0); print(f'Key rate durations: {krd}'); print(f'Sum: {sum(krd.values()):.4f}'); assert sum(krd.values()) > 0"`

Expected: KRDs positive, sum ~1.2 (total duration). No exceptions.
  </verify>
  <done>Key rate durations implemented. Tenor-specific sensitivity calculated. Sum validates against effective duration.</done>
</task>

<task type="auto">
  <name>Task 4: Add comprehensive market risk tests</name>
  <files>compute/tests/test_market_risk.py</files>
  <action>
Create test file with 8 test cases covering all market risk measures:

**test_macaulay_duration()**
- Calculate for 5-year 5% bond
- Assert duration between 4.0 and 5.0 years
- Verify weighted average time calculation

**test_modified_duration()**
- Derive from Macaulay duration
- Assert modified < macaulay (always true)

**test_effective_duration_positive_convexity()**
- Typical bond with positive convexity
- Assert effective duration close to modified (for small shocks)

**test_dv01_calculation()**
- $1M bond with 5% duration
- 1bp rate increase → ~$500 loss
- Assert DV01 between 400 and 600

**test_convexity_positive()**
- Typical bond → positive convexity
- Assert convexity > 0
- Verify PV_down + PV_up > 2 * PV_base

**test_spread_duration()**
- Corporate bond with credit spread
- 25bp spread widening → price decline
- Assert spread duration > 0

**test_key_rate_durations_sum()**
- Calculate KRDs for 3 tenors
- Sum of KRDs ≈ effective duration
- Assert abs(sum(krd) - eff_dur) / eff_dur < 0.15 (15% tolerance)

**test_key_rate_durations_callable_bond()**
- Callable bond has negative duration in some tenors (call option effect)
- Assert some KRDs may be negative

Use pytest fixtures for sample bonds and cashflows. Validate against QuantLib BondFunctions where possible.
  </action>
  <verify>Run: `pytest compute/tests/test_market_risk.py -v`</verify>
  <done>8 market risk tests pass. Duration, DV01, convexity, key rate durations validated. Formulas match financial standards.</done>
</task>

</tasks>

<verification>
- [ ] Macaulay duration calculates weighted average time to cashflows
- [ ] Modified duration formula correct (MacD / (1 + y/f))
- [ ] Effective duration from bump-reprice matches expected
- [ ] DV01 represents dollar value of 1bp change
- [ ] Convexity positive for typical bonds
- [ ] Spread duration measures credit spread sensitivity
- [ ] Key rate durations sum to effective duration (within tolerance)
- [ ] 8 tests pass covering all market risk measures
</verification>

<success_criteria>
- Duration calculations (RISK-01) implemented: Macaulay, Modified, Effective
- DV01/PV01 calculations (RISK-02) working correctly
- Convexity calculation (RISK-02) measures second-order sensitivity
- Key rate duration (RISK-03) computed for major tenors
- Spread duration (RISK-03) measures credit spread sensitivity
- All formulas match industry standards and regulatory requirements
- 8 comprehensive tests validate calculations
- Integration with pricers via bump-reprice pattern
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-07-SUMMARY.md`
</output>
