---
phase: 02-core-compute-engines
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - compute/quantlib/curve_builder.py
  - compute/quantlib/interpolation.py
  - compute/quantlib/day_count.py
  - compute/quantlib/calendar.py
  - compute/quantlib/fx.py
autonomous: true

must_haves:
  truths:
    - "Yield curves bootstrap from market instruments (deposits, swaps)"
    - "Multiple interpolation methods available (LogCubic, Linear, CubicSpline)"
    - "Day count conventions handle all ISDA variants correctly"
    - "Business day calendars adjust dates per market conventions"
  artifacts:
    - path: "compute/quantlib/curve_builder.py"
      provides: "QuantLib PiecewiseYieldCurve wrappers"
      exports: ["build_discount_curve", "build_forward_curve", "build_basis_curve"]
    - path: "compute/quantlib/interpolation.py"
      provides: "QuantLib interpolation adapters"
      exports: ["InterpolationMethod"]
    - path: "compute/quantlib/day_count.py"
      provides: "QuantLib DayCounter wrappers"
      exports: ["get_day_counter"]
    - path: "compute/quantlib/calendar.py"
      provides: "QuantLib Calendar wrappers"
      exports: ["get_calendar"]
  key_links:
    - from: "compute/quantlib/curve_builder.py"
      to: "QuantLib.PiecewiseLogCubicDiscount"
      via: "import QuantLib as ql"
      pattern: "ql\\.Piecewise.*Discount"
    - from: "compute/quantlib/day_count.py"
      to: "QuantLib.Actual360|ActualActual|Thirty360"
      via: "DayCounter factory"
      pattern: "ql\\.Actual.*|ql\\.Thirty360"
---

<objective>
Implement QuantLib-based curve construction, interpolation methods, day count conventions, and business day calendars. Establishes the financial mathematics foundation for all institutional-grade pricers.

Purpose: All downstream pricers (callable bonds, ABS/MBS, derivatives) depend on accurate curve bootstrapping, correct day count calculations, and holiday-aware date adjustments. This plan delivers the core QuantLib integration layer.

Output: Functional curve_builder, interpolation, day_count, and calendar modules with QuantLib 1.41 bindings.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/pricers/bond.py
@compute/quantlib/curve.py
@compute/quantlib/scenarios.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement QuantLib curve construction with multi-curve support</name>
  <files>compute/quantlib/curve_builder.py</files>
  <action>
Replace stub implementation with QuantLib PiecewiseYieldCurve bootstrapping. Implement three functions:

1. **build_discount_curve()** - Bootstrap OIS discount curve from deposits and swaps using QuantLib PiecewiseLogCubicDiscount. Accept market_data dict with instruments (type, rate, tenor, fixing_days). Create DepositRateHelper and SwapRateHelper for each instrument. Use QuantLib's built-in bootstrapping algorithm. Enable extrapolation. Force evaluation immediately after construction (fail-fast on bad data).

2. **build_forward_curve()** - Build SOFR/LIBOR forward projection curve for given tenor (3M, 6M). Use PiecewiseLogCubicDiscount with tenor-specific helpers. Support multi-curve framework (separate discount and projection curves per research pattern 2).

3. **build_basis_curve()** - Apply basis spreads to base curve using ZeroSpreadedTermStructure. Accept list of tenor/spread pairs. Return modified curve for cross-currency or tenor basis.

Use patterns from research section "Pattern 2: Yield Curve Construction Pattern". Set evaluation date from market_data. Handle missing instruments gracefully (raise clear ValueError with missing tenor). Return QuantLib YieldTermStructure objects (not custom ZeroCurve).

**Do NOT hand-roll bootstrapping** — use QuantLib's proven algorithm (per research "Don't Hand-Roll" section).
  </action>
  <verify>
Run: `python -c "from compute.quantlib.curve_builder import build_discount_curve; import QuantLib as ql; md = {'calc_date': ql.Date(15,1,2026), 'instruments': [{'type': 'DEPOSIT', 'rate': 0.025, 'tenor': '3M', 'fixing_days': 2}]}; c = build_discount_curve(md, 'USD-OIS'); print(c.discount(ql.Date(15,4,2026)))"`

Expected: Returns discount factor ~0.9938 (3 months at 2.5%). No exceptions.
  </verify>
  <done>build_discount_curve() bootstraps curve from market instruments and returns QuantLib YieldTermStructure. build_forward_curve() supports multi-curve framework. build_basis_curve() applies basis spreads. All functions raise clear errors for bad inputs.</done>
</task>

<task type="auto">
  <name>Task 2: Implement QuantLib day count conventions and calendar wrappers</name>
  <files>compute/quantlib/day_count.py, compute/quantlib/calendar.py, compute/quantlib/interpolation.py</files>
  <action>
Replace stub implementations with QuantLib adapters:

**day_count.py:**
- Implement `get_day_counter(convention: str) -> ql.DayCounter` factory function
- Support conventions: "ACT/360", "ACT/365", "ACT/ACT", "30/360", "30E/360", "ACT/ACT-ISDA", "ACT/ACT-ICMA"
- Map to QuantLib classes: Actual360(), Actual365Fixed(), ActualActual(variant), Thirty360(variant)
- Raise ValueError for unsupported conventions with helpful message listing valid options
- Add helper: `year_fraction(start_date, end_date, convention)` wrapping DayCounter.yearFraction()

**calendar.py:**
- Implement `get_calendar(name: str) -> ql.Calendar` factory function
- Support calendars: "US", "US-GOVT", "UK", "TARGET" (Eurozone), "JAPAN", "NULLCALENDAR"
- Map to QuantLib: UnitedStates(variant), UnitedKingdom(), TARGET(), Japan(), NullCalendar()
- Add helper: `adjust_date(date, calendar, convention)` for business day adjustments
- Add helper: `is_business_day(date, calendar) -> bool`

**interpolation.py:**
- Implement InterpolationMethod enum or constants: LOG_CUBIC, LINEAR, CUBIC_SPLINE, LOGLINEAR
- Add function: `get_interpolation_name(method) -> str` for logging/debugging
- Document when to use each method (LogCubic for discount factors, Linear for zero rates, per research)

Use QuantLib's DayCounter and Calendar classes directly — **do NOT implement date arithmetic manually** (per research pitfall 3).
  </action>
  <verify>
Run: `python -c "from compute.quantlib.day_count import get_day_counter, year_fraction; from compute.quantlib.calendar import get_calendar, is_business_day; import QuantLib as ql; dc = get_day_counter('ACT/360'); yf = year_fraction(ql.Date(1,1,2026), ql.Date(1,4,2026), 'ACT/360'); print(f'Year fraction: {yf}'); cal = get_calendar('US-GOVT'); print(f'Jan 1 2026 is business day: {is_business_day(ql.Date(1,1,2026), cal)}')"`

Expected: Year fraction ~0.247 (89/360). Jan 1 2026 returns False (New Year's Day holiday). No exceptions.
  </verify>
  <done>get_day_counter() returns correct QuantLib DayCounter for all supported conventions. get_calendar() returns QuantLib Calendar with accurate holiday rules. year_fraction() and date adjustment helpers work correctly. interpolation.py defines interpolation method constants.</done>
</task>

<task type="auto">
  <name>Task 3: Add golden tests for curve construction and conventions</name>
  <files>compute/tests/golden/test_curve_golden.py</files>
  <action>
Create golden test file with 4 test cases validating curve construction and conventions:

**Test 1: test_discount_curve_bootstrap()**
- Build discount curve from 3 deposits (1M, 3M, 6M) and 2 swaps (2Y, 5Y) with known rates
- Verify discount factors at each maturity match expected values (compute manually or use QuantLib reference)
- Verify curve extrapolates beyond 5Y without errors

**Test 2: test_day_count_conventions()**
- Calculate year fractions for same date range using ACT/360, ACT/365, 30/360
- Assert results match expected: 90 days = 0.25 (ACT/360), 0.2466 (ACT/365), 0.25 (30/360 if month-aligned)
- Verify leap year handling (Feb 29)

**Test 3: test_business_day_calendar()**
- Check US-GOVT calendar for known holidays: Jan 1 2026 (New Year), July 4 2026 (Independence Day)
- Verify adjust_date() moves weekend/holiday dates to next business day
- Check TARGET calendar differs from US (different holiday sets)

**Test 4: test_multi_curve_framework()**
- Build OIS discount curve and 3M SOFR forward curve from same market data
- Verify curves differ (basis spread present)
- Price a simple swap using both curves (discount with OIS, project with SOFR)

Use pytest fixtures for market data. Follow existing golden test patterns from compute/tests/golden/*.
  </action>
  <verify>Run: `pytest compute/tests/golden/test_curve_golden.py -v`</verify>
  <done>4 golden tests pass. Curve bootstrapping, day count conventions, calendar logic, and multi-curve framework validated against reference calculations.</done>
</task>

</tasks>

<verification>
- [ ] QuantLib 1.41 imported successfully: `python -c "import QuantLib as ql; print(ql.__version__)"`
- [ ] Curve bootstrapping works end-to-end with real market data
- [ ] Day count conventions produce correct year fractions for ACT/360, ACT/365, 30/360
- [ ] US-GOVT calendar correctly identifies Jan 1 and July 4 as holidays
- [ ] All 4 golden tests pass
- [ ] No hand-rolled date arithmetic (all via QuantLib)
</verification>

<success_criteria>
- build_discount_curve() bootstraps curves from deposits and swaps using QuantLib PiecewiseYieldCurve
- Multi-curve framework supports separate discount and forward curves
- Day count conventions (ACT/360, ACT/365, 30/360) implemented via QuantLib DayCounter
- Business day calendars (US-GOVT, TARGET) implemented via QuantLib Calendar
- 4 golden tests validate curve construction, day counts, calendars, and multi-curve framework
- All QuantLib integration follows research patterns (no hand-rolled financial math)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-01-SUMMARY.md`
</output>
