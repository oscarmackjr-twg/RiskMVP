---
phase: 02-core-compute-engines
plan: 03
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - compute/pricers/floating_rate.py
  - compute/pricers/registry.py
  - compute/cashflow/arm_reset.py
  - compute/tests/golden/test_floating_rate_golden.py
autonomous: true

must_haves:
  truths:
    - "Floating-rate instruments price with index-based coupon resets"
    - "Coupon projections use forward curve (not just spot rate)"
    - "ARM reset logic handles lookback periods and spread"
    - "Multi-curve framework separates discount and projection curves"
  artifacts:
    - path: "compute/pricers/floating_rate.py"
      provides: "Floating-rate bond/loan pricer"
      exports: ["price_floating_rate"]
      min_lines: 70
    - path: "compute/cashflow/arm_reset.py"
      provides: "Index reset and coupon calculation"
      exports: ["calculate_reset_coupon"]
      min_lines: 40
  key_links:
    - from: "compute/pricers/floating_rate.py"
      to: "QuantLib.FloatingRateBond"
      via: "instrument creation"
      pattern: "FloatingRateBond"
    - from: "compute/pricers/floating_rate.py"
      to: "compute.quantlib.curve_builder.build_forward_curve"
      via: "projection curve"
      pattern: "build_forward_curve"
---

<objective>
Implement floating-rate instrument pricer (PRICE-01) with index-based coupon resets and ARM reset logic (CF-04). Uses QuantLib FloatingRateBond with multi-curve framework (separate discount and projection curves).

Purpose: Floating-rate loans and bonds are core to institutional portfolios. Accurate pricing requires forward rate projection (not just spot rates) and correct handling of index lookback periods, spreads, caps/floors.

Output: Floating-rate pricer registered in registry with ARM reset logic and golden tests.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-compute-engines/02-RESEARCH.md
@compute/pricers/bond.py
@compute/pricers/loan.py
@compute/quantlib/curve_builder.py
@compute/cashflow/arm_reset.py
</context>

<feature>
  <name>Floating-Rate Pricer</name>
  <files>compute/pricers/floating_rate.py, compute/cashflow/arm_reset.py, compute/tests/golden/test_floating_rate_golden.py</files>
  <behavior>
    Given: Floating-rate note, quarterly resets, 3M SOFR + 150 bps, 3-year maturity
    When: price_floating_rate() called with measures=['PV', 'DV01']
    Then: Returns PV using forward SOFR curve for coupon projection, OIS curve for discounting

    Cases:
    - Flat forward curve → coupons constant at spot + spread
    - Upward-sloping curve → later coupons project higher
    - Spread shock scenario → PV changes with spread curve
    - Cap/floor embedded → price includes option value
  </behavior>
  <implementation>
1. Build two curves: OIS discount curve and SOFR forward curve (3M tenor) using curve_builder
2. Create QuantLib IborIndex (e.g., USDLibor or SOFR equivalent) linked to forward curve
3. Build FloatingRateBond with:
   - Schedule from issue/maturity dates and reset frequency
   - Index for coupon resets
   - Spread (e.g., 150 bps)
   - Optional cap/floor rates
4. Set DiscountingBondEngine with OIS curve
5. Compute measures: NPV() for PV, bump-reprice for DV01
6. ARM reset logic in arm_reset.py: calculate_reset_coupon(index_rate, spread, cap, floor, day_count_fraction)

Follow multi-curve pattern from research. Use separate discount and projection curves per post-2008 standard.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Write failing test for floating-rate pricing</name>
  <files>compute/tests/golden/test_floating_rate_golden.py</files>
  <action>
Create test file with 3 test cases:

**test_floating_rate_basic()**
- 3M SOFR floater, quarterly resets, +150 bps spread, 3-year maturity
- Flat 3.5% SOFR curve, 3.4% OIS curve (10 bp basis)
- Expected: PV close to par (100) since floating rate adjusts to market
- Assert abs(result['PV'] - 100.0) < 2.0

**test_floating_rate_with_cap()**
- Same floater but with 5% cap
- Steep upward-sloping curve (3% -> 6%)
- Expected: PV < par (cap reduces value in rising rate environment)
- Assert result['PV'] < 98.0

**test_floating_rate_multi_curve()**
- Price with and without basis spread between OIS and SOFR curves
- Assert PV differs when basis spread changes
- Validates multi-curve framework

Run tests (MUST fail - pricer not implemented). Commit: `test(02-03): add failing tests for floating-rate pricer`
  </action>
  <verify>Run: `pytest compute/tests/golden/test_floating_rate_golden.py -v`. Expected: 3 failures</verify>
  <done>Test file created with 3 failing tests for floating-rate pricer.</done>
</task>

<task type="auto">
  <name>GREEN: Implement ARM reset logic</name>
  <files>compute/cashflow/arm_reset.py</files>
  <action>
Replace stub with implementation:

```python
def calculate_reset_coupon(
    index_rate: float,
    spread: float,
    cap: float | None = None,
    floor: float | None = None,
    day_count_fraction: float = 0.25,
) -> float:
    """Calculate coupon rate for floating-rate instrument reset.

    Args:
        index_rate: Reference rate (e.g., 3M SOFR) as decimal (0.035 = 3.5%)
        spread: Fixed spread in decimal (0.015 = 150 bps)
        cap: Optional cap rate (decimal)
        floor: Optional floor rate (decimal)
        day_count_fraction: Accrual period (0.25 for quarterly)

    Returns:
        Coupon rate as decimal
    """
    coupon_rate = index_rate + spread

    if cap is not None:
        coupon_rate = min(coupon_rate, cap)
    if floor is not None:
        coupon_rate = max(coupon_rate, floor)

    return coupon_rate
```

Add helper for lookback logic if needed (index observed N days before reset date).

Run unit test. Commit: `feat(02-03): implement ARM reset logic`
  </action>
  <verify>Run: `python -c "from compute.cashflow.arm_reset import calculate_reset_coupon; r = calculate_reset_coupon(0.035, 0.015, cap=0.05); print(f'Coupon: {r*100:.2f}%'); assert r == 0.05"`</verify>
  <done>ARM reset logic implemented with cap/floor handling. Unit test passes.</done>
</task>

<task type="auto">
  <name>GREEN: Implement floating-rate pricer</name>
  <files>compute/pricers/floating_rate.py</files>
  <action>
Replace stub with full implementation:

1. Import QuantLib, curve_builder, arm_reset
2. Implement price_floating_rate(position, instrument, market_snapshot, measures, scenario_id):
   - Apply scenario
   - Set evaluation date
   - Build OIS discount curve: build_discount_curve(market_data, 'USD-OIS')
   - Build SOFR forward curve: build_forward_curve(market_data, 'USD-SOFR', '3M')
   - Create IborIndex: ql.USDLibor(ql.Period(3, ql.Months)) or custom SOFR index
   - Link index to forward curve: index.addFixing() for historical resets, or use forecast
   - Build schedule: ql.MakeSchedule(issue_date, maturity_date, ql.Quarterly)
   - Create FloatingRateBond:
     - settlement_days=2
     - faceAmount=100.0
     - schedule
     - index
     - day count convention
     - spread from instrument (e.g., 0.015 for 150 bps)
     - gearings=[1.0] (no leverage)
     - caps/floors if present in instrument
   - Set DiscountingBondEngine with OIS curve handle
   - Compute measures:
     - 'PV' → bond.NPV()
     - 'DV01' → bump OIS curve +1bp, reprice
   - Return results

Handle scenarios via curve relinking (apply rate/spread shocks to appropriate curve).

Run tests (MUST pass). Commit: `feat(02-03): implement floating-rate pricer with multi-curve`
  </action>
  <verify>Run: `pytest compute/tests/golden/test_floating_rate_golden.py -v`. Expected: 3 passes</verify>
  <done>Floating-rate pricer implemented. Multi-curve framework working. Cap/floor handling correct. Tests pass.</done>
</task>

<task type="auto">
  <name>Register floating-rate pricer and refactor</name>
  <files>compute/pricers/registry.py</files>
  <action>
Update _bootstrap() in registry.py:

Add import:
```python
from compute.pricers.floating_rate import price_floating_rate
```

Add registration:
```python
register("FLOATING_RATE", price_floating_rate)
```

Run registry tests. Verify 6 pricers registered.

**REFACTOR (if needed):** Extract common curve-building logic from callable, putable, and floating-rate pricers into shared helper (e.g., compute/quantlib/curve_helpers.py). Only refactor if duplication is significant (>30 lines repeated). Do NOT refactor if tests would break.

Commit: `feat(02-03): register floating-rate pricer`
  </action>
  <verify>Run: `python -c "from compute.pricers.registry import registered_types; print(len(registered_types()))"`. Expected: 6</verify>
  <done>Floating-rate pricer registered. Worker can dispatch FLOATING_RATE product types.</done>
</task>

</tasks>

<verification>
- [ ] 3 floating-rate golden tests pass
- [ ] Multi-curve framework validated (different results with/without basis)
- [ ] Cap/floor embedded options handled correctly
- [ ] ARM reset logic tested independently
- [ ] Floating-rate pricer registered
- [ ] Floater near par with flat curve (floating rate property)
</verification>

<success_criteria>
- price_floating_rate() prices floating-rate bonds/loans using QuantLib FloatingRateBond
- Multi-curve framework separates OIS discount curve from SOFR projection curve
- ARM reset logic (CF-04) handles index + spread + cap/floor
- Cap and floor embedded options correctly valued
- 3 golden tests pass validating flat curve, capped floater, and multi-curve basis
- Pricer registered and functional in worker
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-compute-engines/02-03-SUMMARY.md`
</output>
