---
phase: 04-regulatory-analytics-reporting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - compute/regulatory/cecl.py
  - compute/regulatory/basel.py
  - compute/regulatory/gaap_ifrs.py
  - compute/tests/test_cecl.py
  - compute/tests/test_basel.py
autonomous: true

must_haves:
  truths:
    - "CECL allowance calculated using multi-scenario ASC 326 approach"
    - "Basel III RWA computed using standardized approach risk weights"
    - "GAAP/IFRS valuation methods produce different results for same position"
  artifacts:
    - path: "compute/regulatory/cecl.py"
      provides: "CECL allowance calculation with stage classification"
      exports: ["compute_cecl_allowance", "stage_classification", "compute_lifetime_pd"]
      min_lines: 150
    - path: "compute/regulatory/basel.py"
      provides: "Basel III RWA calculation and capital ratios"
      exports: ["compute_basel_rwa", "get_risk_weight", "compute_capital_ratios"]
      min_lines: 120
    - path: "compute/regulatory/gaap_ifrs.py"
      provides: "GAAP/IFRS valuation framework"
      exports: ["classify_gaap_category", "classify_ifrs_category", "compute_impairment"]
      min_lines: 100
    - path: "compute/tests/test_cecl.py"
      provides: "CECL calculation tests with known scenarios"
      min_lines: 80
  key_links:
    - from: "compute_cecl_allowance"
      to: "compute.risk.credit PD model"
      via: "lookup_pd_curve function"
      pattern: "from compute\\.risk\\.credit"
    - from: "compute_basel_rwa"
      to: "regulatory_reference table"
      via: "risk weight lookup"
      pattern: "SELECT.*regulatory_reference.*RISK_WEIGHT"
    - from: "classify_gaap_category"
      to: "position metadata"
      via: "intent attribute"
      pattern: "position.*intent.*HTM|AFS|TRADING"
---

<objective>
Implement regulatory calculation modules for CECL allowance (ASC 326), Basel III RWA (standardized approach), and GAAP/IFRS valuation classifications. Build on Phase 2 risk analytics (PD curves, LGD) and Phase 3 portfolio data (positions, reference data).

Purpose: Deliver REG-01 (GAAP/IFRS framework), REG-02 (CECL modeling), REG-03 (Basel III capital analytics) compute layer. Enable Phase 4 regulatory service to produce compliant calculations.

Output: Three compute modules with tests, ready for regulatory service integration in Plan 03.
</objective>

<execution_context>
@C:/Users/omack/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omack/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-regulatory-analytics-reporting/04-RESEARCH.md

# Existing compute foundation
@compute/risk/credit/__init__.py
@compute/risk/credit/ead.py
@compute/risk/credit/lgd.py
@compute/quantlib/scenarios.py

# Existing regulatory scaffolding
@compute/regulatory/cecl.py
@compute/regulatory/basel.py
@services/regulatory_svc/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CECL allowance calculation (REG-02)</name>
  <files>
    compute/regulatory/cecl.py
    compute/tests/test_cecl.py
  </files>
  <action>
Complete `compute/regulatory/cecl.py` with ASC 326 multi-scenario CECL allowance calculation following research pattern:

**Functions to implement:**

1. **compute_cecl_allowance(portfolio, pd_curves, lgd_assumptions, macro_scenarios, scenario_weights) -> Dict**
   - Input validation: portfolio is List[Dict] with required fields (position_id, instrument_id, ead, rating, base_ccy)
   - Segment portfolio by obligor/industry/geography (group by issuer_id from instrument metadata)
   - For each segment:
     - Determine current rating from portfolio position or default to "BBB"
     - For each macro scenario:
       - Get PD curve from pd_curves dict using rating key (e.g., pd_curves["BBB"] = [0.01, 0.015, 0.02, ...])
       - If PD curve not found, use fallback: lookup from compute.risk.credit if available, else default to flat 2% PD
       - Compute lifetime PD using _compute_lifetime_pd helper
       - Get LGD from lgd_assumptions dict (default 0.45 if missing)
       - Compute ECL_scenario = EAD * lifetime_PD * LGD
     - Weight scenarios: segment_ecl = sum(scenario_weights[i] * ECL_scenario_i)
   - Apply qualitative adjustment (Q-factor): total_allowance = sum(segment_ecl) * (1 + q_factor)
   - Q-factor default: 0.0 (no adjustment), can be passed as parameter
   - Return: {"total_allowance": float, "by_segment": {segment_id: ecl}, "scenario_detail": List[Dict]}

2. **_compute_lifetime_pd(pd_curve: List[float]) -> float**
   - pd_curve is annual PD for years 1, 2, 3, ..., N
   - Compute lifetime survival probability: S = (1 - pd_1) * (1 - pd_2) * ... * (1 - pd_N)
   - Lifetime PD = 1 - S
   - Cap at 0.999 (99.9% max probability)
   - Example: pd_curve = [0.01, 0.015, 0.02] → lifetime_pd = 1 - (0.99 * 0.985 * 0.98) ≈ 0.0446

3. **stage_classification(current_pd, origination_pd, days_past_due) -> int**
   - Already implemented (stub exists), verify logic:
   - Stage 3: days_past_due > 90
   - Stage 2: current_pd > origination_pd * 2.0 (significant deterioration)
   - Stage 1: else (no significant deterioration)
   - Keep existing implementation, add docstring explaining ASC 326 / IFRS 9 alignment

**Test file: compute/tests/test_cecl.py**

Create golden test with known scenario:
```python
def test_cecl_allowance_single_scenario():
    """CECL allowance with single base scenario."""
    portfolio = [
        {"position_id": "pos-1", "instrument_id": "loan-1", "ead": 1000000,
         "rating": "BBB", "base_ccy": "USD", "issuer_id": "issuer-abc"}
    ]
    pd_curves = {
        "BBB": [0.01, 0.015, 0.02, 0.025, 0.03]  # 5-year PD curve
    }
    lgd_assumptions = {"default": 0.45}
    macro_scenarios = [{"base_rate": 2.5, "unemployment": 4.2}]
    scenario_weights = [1.0]

    result = compute_cecl_allowance(portfolio, pd_curves, lgd_assumptions,
                                     macro_scenarios, scenario_weights)

    # Expected: lifetime PD ≈ 0.096, ECL = 1M * 0.096 * 0.45 ≈ 43,200
    assert result["total_allowance"] > 40000
    assert result["total_allowance"] < 50000
    assert "issuer-abc" in result["by_segment"]

def test_stage_classification():
    """IFRS 9 / CECL stage classification."""
    assert stage_classification(0.02, 0.01, 0) == 1  # Stage 1: no deterioration
    assert stage_classification(0.03, 0.01, 0) == 2  # Stage 2: PD doubled
    assert stage_classification(0.02, 0.01, 100) == 3  # Stage 3: >90 DPD
```

Use existing Phase 2 test patterns (pytest, golden tests, assertions with tolerances).
  </action>
  <verify>
```bash
# Run CECL tests
pytest compute/tests/test_cecl.py -v

# Verify functions exported
python -c "from compute.regulatory.cecl import compute_cecl_allowance, stage_classification, _compute_lifetime_pd; print('Imports OK')"
```
  </verify>
  <done>CECL allowance calculation working with multi-scenario weighting, stage classification implemented, tests passing with known scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Implement Basel III RWA calculation (REG-03)</name>
  <files>
    compute/regulatory/basel.py
    compute/tests/test_basel.py
  </files>
  <action>
Complete `compute/regulatory/basel.py` with Basel III standardized approach RWA calculation following research pattern:

**Functions to implement:**

1. **compute_basel_rwa(portfolio: List[Dict], risk_weights: Dict) -> Dict**
   - Input validation: portfolio has required fields (position_id, ead, counterparty_type, rating)
   - For each position:
     - Get counterparty_type (SOVEREIGN, CORPORATE, RETAIL, UNRATED) from position metadata
     - Get rating from position or default to "UNRATED"
     - Lookup risk weight using get_risk_weight(counterparty_type, rating, risk_weights)
     - Compute position RWA = EAD * risk_weight
     - Aggregate by counterparty_type and rating
   - Compute total RWA = sum of all position RWAs
   - Return: {"total_rwa": float, "by_counterparty_type": Dict, "by_rating": Dict}

2. **get_risk_weight(counterparty_type: str, rating: str, risk_weights: Dict) -> float**
   - Lookup key = (counterparty_type, rating)
   - If found in risk_weights dict, return value
   - Else try (counterparty_type, "ANY") fallback
   - Else default to 1.00 (100% risk weight per Basel III unrated default)
   - Risk weights dict structure (from research):
     ```python
     {
       ('SOVEREIGN', 'AAA'): 0.00,
       ('SOVEREIGN', 'AA'): 0.20,
       ('SOVEREIGN', 'A'): 0.50,
       ('SOVEREIGN', 'BBB'): 1.00,
       ('CORPORATE', 'AAA'): 0.20,
       ('CORPORATE', 'AA'): 0.20,
       ('CORPORATE', 'A'): 0.50,
       ('CORPORATE', 'BBB'): 1.00,
       ('CORPORATE', 'BB'): 1.50,
       ('RETAIL', 'ANY'): 0.75,
       ('UNRATED', 'ANY'): 1.00,
     }
     ```

3. **compute_capital_ratios(total_rwa: float, tier1_capital: float, tier2_capital: float) -> Dict**
   - CET1 ratio = tier1_capital / total_rwa (if total_rwa > 0 else 0.0)
   - Tier 1 ratio = tier1_capital / total_rwa
   - Total capital ratio = (tier1_capital + tier2_capital) / total_rwa
   - Return: {"cet1_ratio": float, "tier1_ratio": float, "total_capital_ratio": float}
   - Ratios expressed as decimals (0.045 = 4.5%)

**Test file: compute/tests/test_basel.py**

Create golden test with known risk weights:
```python
def test_basel_rwa_corporate_portfolio():
    """Basel III RWA for corporate portfolio."""
    portfolio = [
        {"position_id": "pos-1", "ead": 1000000, "counterparty_type": "CORPORATE",
         "rating": "AAA"},
        {"position_id": "pos-2", "ead": 2000000, "counterparty_type": "CORPORATE",
         "rating": "BBB"},
        {"position_id": "pos-3", "ead": 500000, "counterparty_type": "RETAIL",
         "rating": "ANY"},
    ]
    risk_weights = {
        ('CORPORATE', 'AAA'): 0.20,
        ('CORPORATE', 'BBB'): 1.00,
        ('RETAIL', 'ANY'): 0.75,
    }

    result = compute_basel_rwa(portfolio, risk_weights)

    # Expected RWA: 1M*0.20 + 2M*1.00 + 0.5M*0.75 = 200K + 2M + 375K = 2.575M
    assert abs(result["total_rwa"] - 2575000) < 1000
    assert result["by_counterparty_type"]["CORPORATE"] > 2000000
    assert result["by_rating"]["BBB"] == 2000000

def test_capital_ratios():
    """Basel III capital ratios."""
    ratios = compute_capital_ratios(total_rwa=10000000,
                                     tier1_capital=800000,
                                     tier2_capital=200000)

    # CET1 = 800K / 10M = 8%
    assert abs(ratios["cet1_ratio"] - 0.08) < 0.001
    # Total capital = 1M / 10M = 10%
    assert abs(ratios["total_capital_ratio"] - 0.10) < 0.001
```
  </action>
  <verify>
```bash
# Run Basel tests
pytest compute/tests/test_basel.py -v

# Verify functions exported
python -c "from compute.regulatory.basel import compute_basel_rwa, get_risk_weight, compute_capital_ratios; print('Imports OK')"
```
  </verify>
  <done>Basel III RWA calculation working with standardized approach risk weights, capital ratios computed correctly, tests passing with known portfolios</done>
</task>

<task type="auto">
  <name>Task 3: Implement GAAP/IFRS valuation framework (REG-01)</name>
  <files>
    compute/regulatory/gaap_ifrs.py
    compute/tests/test_gaap_ifrs.py
  </files>
  <action>
Create `compute/regulatory/gaap_ifrs.py` with GAAP/IFRS valuation classification and impairment following research pattern:

**Functions to implement:**

1. **classify_gaap_category(position: Dict) -> str**
   - Read position metadata "intent" field (HTM, AFS, TRADING)
   - GAAP categories:
     - "HELD_TO_MATURITY" if intent = "HTM" → historical cost + impairment
     - "AVAILABLE_FOR_SALE" if intent = "AFS" → fair value through OCI
     - "TRADING" if intent = "TRADING" → fair value through P&L
     - Default: "AVAILABLE_FOR_SALE" if no intent specified
   - Return: category string

2. **classify_ifrs_category(position: Dict, business_model: str) -> str**
   - IFRS 9 categories based on business model and contractual cash flow characteristics:
     - "AMORTIZED_COST" if business_model = "HOLD_TO_COLLECT" and cash_flows are SPPI
     - "FVOCI" (Fair Value through OCI) if business_model = "HOLD_AND_SELL" and SPPI
     - "FVTPL" (Fair Value through P&L) otherwise
   - Simplified: Use business_model parameter from caller (HOLD_TO_COLLECT, HOLD_AND_SELL, TRADING)
   - SPPI check: assume true for bonds/loans, false for derivatives (product_type check)
   - Return: category string

3. **compute_impairment(position: Dict, market_value: float, book_value: float, category: str) -> float**
   - GAAP HTM impairment: If market_value < book_value AND impairment is "other than temporary", recognize impairment
   - Simplified impairment test: If market_value < book_value * 0.90 (10% decline), impairment = book_value - market_value
   - GAAP AFS: No impairment to book value (unrealized loss in OCI)
   - IFRS Amortized Cost: ECL-based impairment (use CECL stage from Task 1)
   - Return: impairment amount (0.0 if no impairment)

4. **compute_gaap_valuation(position: Dict, market_value: float, book_value: float) -> Dict**
   - category = classify_gaap_category(position)
   - If HTM: carrying_value = book_value - compute_impairment(...)
   - If AFS: carrying_value = market_value, unrealized_gain_loss = market_value - book_value (in OCI)
   - If TRADING: carrying_value = market_value, realized_gain_loss = market_value - book_value (in P&L)
   - Return: {"category": str, "carrying_value": float, "unrealized_gain_loss": float, "impairment": float}

5. **compute_ifrs_valuation(position: Dict, market_value: float, book_value: float, ecl_allowance: float) -> Dict**
   - category = classify_ifrs_category(position, business_model from position metadata)
   - If AMORTIZED_COST: carrying_value = book_value - ecl_allowance
   - If FVOCI: carrying_value = market_value, unrealized_gain_loss = market_value - book_value (in OCI)
   - If FVTPL: carrying_value = market_value
   - Return: {"category": str, "carrying_value": float, "ecl_allowance": float}

**Test file: compute/tests/test_gaap_ifrs.py**

Create test with known classifications:
```python
def test_gaap_classification():
    """GAAP category classification by intent."""
    assert classify_gaap_category({"intent": "HTM"}) == "HELD_TO_MATURITY"
    assert classify_gaap_category({"intent": "AFS"}) == "AVAILABLE_FOR_SALE"
    assert classify_gaap_category({"intent": "TRADING"}) == "TRADING"
    assert classify_gaap_category({}) == "AVAILABLE_FOR_SALE"  # Default

def test_gaap_htm_impairment():
    """GAAP HTM impairment on significant decline."""
    position = {"intent": "HTM", "product_type": "FIXED_BOND"}
    # Market value 85% of book → 15% impairment
    result = compute_gaap_valuation(position, market_value=850000, book_value=1000000)

    assert result["category"] == "HELD_TO_MATURITY"
    assert result["impairment"] == 150000  # 15% of book
    assert result["carrying_value"] == 850000  # Book - impairment

def test_ifrs_amortized_cost_with_ecl():
    """IFRS amortized cost with ECL allowance."""
    position = {"business_model": "HOLD_TO_COLLECT", "product_type": "AMORT_LOAN"}
    result = compute_ifrs_valuation(position, market_value=980000,
                                     book_value=1000000, ecl_allowance=50000)

    assert result["category"] == "AMORTIZED_COST"
    assert result["carrying_value"] == 950000  # Book - ECL
    assert result["ecl_allowance"] == 50000
```
  </action>
  <verify>
```bash
# Run GAAP/IFRS tests
pytest compute/tests/test_gaap_ifrs.py -v

# Verify functions exported
python -c "from compute.regulatory.gaap_ifrs import classify_gaap_category, classify_ifrs_category, compute_gaap_valuation, compute_ifrs_valuation; print('Imports OK')"
```
  </verify>
  <done>GAAP/IFRS valuation framework working with HTM/AFS/TRADING classification, impairment calculation, and ECL integration for IFRS amortized cost; tests passing</done>
</task>

</tasks>

<verification>
# CECL Module (REG-02)
- [ ] compute_cecl_allowance returns total_allowance, by_segment, scenario_detail
- [ ] Multi-scenario weighting implemented correctly
- [ ] stage_classification returns 1, 2, or 3 based on PD and DPD
- [ ] Tests pass with known scenarios

# Basel Module (REG-03)
- [ ] compute_basel_rwa aggregates by counterparty type and rating
- [ ] get_risk_weight returns correct values from Basel III table
- [ ] compute_capital_ratios computes CET1, Tier 1, Total Capital correctly
- [ ] Tests pass with known portfolios

# GAAP/IFRS Module (REG-01)
- [ ] classify_gaap_category returns HTM/AFS/TRADING
- [ ] classify_ifrs_category returns AMORTIZED_COST/FVOCI/FVTPL
- [ ] compute_impairment identifies >10% declines for HTM
- [ ] compute_gaap_valuation and compute_ifrs_valuation return correct carrying values
- [ ] Tests pass with known positions

# All tests passing
- [ ] pytest compute/tests/test_cecl.py passes
- [ ] pytest compute/tests/test_basel.py passes
- [ ] pytest compute/tests/test_gaap_ifrs.py passes
</verification>

<success_criteria>
1. CECL allowance calculation implements ASC 326 multi-scenario approach with stage classification
2. Basel III RWA calculation uses standardized approach risk weights from regulatory reference
3. GAAP/IFRS valuation framework classifies positions correctly and computes impairment
4. All regulatory compute modules have golden tests with known scenarios
5. Modules integrate with Phase 2 risk analytics (PD curves, LGD assumptions)
6. Code follows Phase 2 compute patterns (type hints, docstrings, error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/04-regulatory-analytics-reporting/04-02-SUMMARY.md`
</output>
